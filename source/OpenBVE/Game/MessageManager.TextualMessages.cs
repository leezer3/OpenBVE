using System;
using DavyKager;
using LibRender2.Text;
using OpenBveApi.Trains;
using RouteManager2.MessageManager;

namespace OpenBve
{
	/*
	 * This class holds the definitions for textual messages
	 */
	internal partial class MessageManager
	{
		/// <summary>Defines a textual message generated by the game</summary>
		internal class GameMessage : AbstractMessage
		{
			/// <summary>The internal (non-translated) string</summary>
			internal string InternalText;
			/// <summary>The action which triggered this message (route, speed limit etc.)</summary>
			internal MessageDependency Depencency;

			/// <summary>The font used for this message</summary>
			internal OpenGlFont Font;
			/// <summary>Whether the message has been announced by the screen reader</summary>
			private bool ScreenReaderAnnounced;

			public override void AddMessage(double currentTime)
			{
				//HACK: No way of changing this at the minute....
				Font = Program.Renderer.Fonts.SmallFont;
				QueueForRemoval = false;
				MessageToDisplay = InternalText;
				ScreenReaderAnnounced = false;
			}

			public override void Update(double timeElapsed)
			{
				Timeout -= timeElapsed;
				// If our message timeout has elapsed, queue it for removal
				bool remove = Timeout <= 0;

				switch (Depencency)
				{
					case MessageDependency.AccessibilityHelper:
					case MessageDependency.RouteLimit:
					{
						double spd = Math.Abs(TrainManager.PlayerTrain.CurrentSpeed);
						double nextLim = TrainManager.CurrentRoute.NextLimit(TrainManager.PlayerTrain.Cars[0].FrontAxle.Follower.LastTrackElement, out double nextLimPos);
						double lim = TrainManager.PlayerTrain.CurrentRouteLimit;
						nextLimPos -= TrainManager.PlayerTrain.FrontCarTrackPosition;
						nextLimPos = Math.Round(nextLimPos);

						remove = spd < lim;
						
						// Convert the speed and limit into km/h for display purposes
						spd = Math.Round(spd * 3.6);
						lim = Math.Round(lim * 3.6);
						nextLim = Math.Round(nextLim * 3.6);
						string s = InternalText;

						if (Interface.CurrentOptions.SpeedConversionFactor != 0.0)
						{
							spd = Math.Round(spd * Interface.CurrentOptions.SpeedConversionFactor);
							lim = Math.Round(lim * Interface.CurrentOptions.SpeedConversionFactor);	
							nextLim = Math.Round(nextLim * Interface.CurrentOptions.SpeedConversionFactor);
						}

						if (lim == double.PositiveInfinity)
						{
							s = s.Replace("[limit]", "unlimited");
							s = s.Replace("[unit]", string.Empty);
						}
						else
						{
							string t = spd.ToString(System.Globalization.CultureInfo.InvariantCulture);
							s = s.Replace("[speed]", t);
							t = lim.ToString(System.Globalization.CultureInfo.InvariantCulture);
							s = s.Replace("[limit]", t);
							s = s.Replace("[unit]", Interface.CurrentOptions.UnitOfSpeed);
						}

						if (nextLim == double.PositiveInfinity)
						{
							s = s.Replace("[nextlimit]", "n/a");
							s = s.Replace("[limitdistance]", "n/a");
							s = s.Replace("[limitunit]", string.Empty);
						}
						else
						{
							string t = nextLim.ToString(System.Globalization.CultureInfo.InvariantCulture);
							s = s.Replace("[nextlimit]", t);
							t = nextLimPos.ToString(System.Globalization.CultureInfo.InvariantCulture);
							s = s.Replace("[limitdistance]", t);
							s = s.Replace("[limitunit]", Interface.CurrentOptions.UnitOfSpeed);
						}
						
						MessageToDisplay = s;
					} break;
					case MessageDependency.PassedRedSignal:
					case MessageDependency.SectionLimit:
					{
						double spd = Math.Abs(TrainManager.PlayerTrain.CurrentSpeed);
						double lim = TrainManager.PlayerTrain.CurrentSectionLimit;
						spd = Math.Round(spd * 3.6);
						lim = Math.Round(lim * 3.6);
						remove = spd <= lim;
						if (Interface.CurrentOptions.SpeedConversionFactor != 0.0)
						{
							spd = Math.Round(spd * Interface.CurrentOptions.SpeedConversionFactor);
							lim = Math.Round(lim * Interface.CurrentOptions.SpeedConversionFactor);
						}
						string s = InternalText.Replace("[speed]", spd.ToString(System.Globalization.CultureInfo.InvariantCulture));
						s = s.Replace("[limit]", lim.ToString(System.Globalization.CultureInfo.InvariantCulture));
						s = s.Replace("[unit]", Interface.CurrentOptions.UnitOfSpeed);
						MessageToDisplay = s;
					} break;
					case MessageDependency.StationArrival:
					case MessageDependency.StationDeparture:
					{
						int j = TrainManager.PlayerTrain.Station;
						if (j >= 0 & TrainManager.PlayerTrain.StationState != TrainStopState.Completed)
						{
							double d = TrainManager.PlayerTrain.StationDepartureTime - Program.CurrentRoute.SecondsSinceMidnight + 1.0;
							if (d < 0.0) d = 0.0;
							string s = InternalText;
							TimeSpan a = TimeSpan.FromSeconds(d);
							System.Globalization.CultureInfo Culture = System.Globalization.CultureInfo.InvariantCulture;
							string t = a.Hours.ToString("00", Culture) + ":" + a.Minutes.ToString("00", Culture) + ":" + a.Seconds.ToString("00", Culture);
							s = s.Replace("[time]", t);
							s = s.Replace("[name]", Program.CurrentRoute.Stations[j].Name);
							MessageToDisplay = s;
							if (d > 0.0) remove = false;
						}
						else
						{
							//Queue the mesasge for removal if we have completed the station stop for this message
							remove = true;
						}
					} break;
					default:
						MessageToDisplay = InternalText;
						break;
				}

				if (Interface.CurrentOptions.ScreenReaderAvailable && !ScreenReaderAnnounced)
				{
					if (!Tolk.Output((string) MessageToDisplay))
					{
						Interface.CurrentOptions.ScreenReaderAvailable = false;
					}
					ScreenReaderAnnounced = true;
				}
				if (remove)
				{
					if (Timeout == double.PositiveInfinity)
					{
						Timeout = -1.0;
					}
					//Remove the message if it has completely faded out
					//NOTE: The fadeout is done in the renderer itself...
					if (Timeout <= 0 & RendererAlpha == 0.0)
					{
						QueueForRemoval = true;
					}
				}
			}
		}

		



		
	}
}
