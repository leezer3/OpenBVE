using System;
using SoundManager;

namespace OpenBve
{
	public static partial class TrainManager
	{
		internal class MotorCar : Car
		{
			/// <summary>Holds the acceleration curves generated by the motor</summary>
			internal AccelerationCurve[] AccelerationCurves;

			internal double DecelerationDueToMotor;


			internal MotorCar(Train train, int index) : base(train, index)
			{
			}

			internal override void UpdateAcceleration(double TimeElapsed)
			{
				// power
				WheelSpin = 0.0;
				double wheelSlipAccelerationMotorFront;
				double wheelSlipAccelerationMotorRear;
				if (Derailed)
				{
					wheelSlipAccelerationMotorFront = 0.0;
					wheelSlipAccelerationMotorRear = 0.0;
				}
				else
				{
					wheelSlipAccelerationMotorFront = GetCriticalWheelSlipAccelerationForElectricMotor(FrontAxle, CurrentSpeed);
					wheelSlipAccelerationMotorRear = GetCriticalWheelSlipAccelerationForElectricMotor(RearAxle, CurrentSpeed);
				}

				if (DecelerationDueToMotor == 0.0)
				{
					double a;
					if (DecelerationDueToMotor == 0.0)
					{
						if (baseTrain.Handles.Reverser.Actual != 0 & baseTrain.Handles.Power.Actual > 0 & !baseTrain.Handles.HoldBrake.Actual & !baseTrain.Handles.EmergencyBrake.Actual)
						{
							// target acceleration
							if (baseTrain.Handles.Power.Actual - 1 < AccelerationCurves.Length)
							{
								// Load factor is a constant 1.0 for anything prior to BVE5
								// This will need to be changed when the relevant branch is merged in
								a = AccelerationCurves[baseTrain.Handles.Power.Actual - 1].GetAccelerationOutput((double)baseTrain.Handles.Reverser.Actual * CurrentSpeed, 1.0);
							}
							else
							{
								a = 0.0;
							}

							// readhesion device
							if (a > Specs.ReAdhesionDevice.MaximumAccelerationOutput)
							{
								a = Specs.ReAdhesionDevice.MaximumAccelerationOutput;
							}

							// wheel slip
							if (a < wheelSlipAccelerationMotorFront)
							{
								FrontAxle.CurrentWheelSlip = false;
							}
							else
							{
								FrontAxle.CurrentWheelSlip = true;
								WheelSpin += (double)baseTrain.Handles.Reverser.Actual * a * Specs.MassCurrent;
							}

							if (a < wheelSlipAccelerationMotorRear)
							{
								RearAxle.CurrentWheelSlip = false;
							}
							else
							{
								RearAxle.CurrentWheelSlip = true;
								WheelSpin += (double)baseTrain.Handles.Reverser.Actual * a * Specs.MassCurrent;
							}

							// Update readhesion device
							Specs.ReAdhesionDevice.Update(a);

							// Update constant speed device
							Specs.ConstSpeed.Update(ref a, baseTrain.Specs.CurrentConstSpeed, baseTrain.Handles.Reverser.Actual);

							// finalize
							if (WheelSpin != 0.0)
							{
								a = 0.0;
							}
						}
						else
						{
							a = 0.0;
							FrontAxle.CurrentWheelSlip = false;
							RearAxle.CurrentWheelSlip = false;
						}
					}
					else
					{
						a = 0.0;
						FrontAxle.CurrentWheelSlip = false;
						RearAxle.CurrentWheelSlip = false;
					}

					if (!Derailed)
					{
						if (Specs.CurrentAccelerationOutput < a)
						{
							if (Specs.CurrentAccelerationOutput < 0.0)
							{
								Specs.CurrentAccelerationOutput += Specs.JerkBrakeDown * TimeElapsed;
							}
							else
							{
								Specs.CurrentAccelerationOutput += Specs.JerkPowerUp * TimeElapsed;
							}

							if (Specs.CurrentAccelerationOutput > a)
							{
								Specs.CurrentAccelerationOutput = a;
							}
						}
						else
						{
							Specs.CurrentAccelerationOutput -= Specs.JerkPowerDown * TimeElapsed;
							if (Specs.CurrentAccelerationOutput < a)
							{
								Specs.CurrentAccelerationOutput = a;
							}
						}
					}
					else
					{
						Specs.CurrentAccelerationOutput = 0.0;
					}
				}
			}

			internal override void UpdateBrakeDeceleration(double TimeElapsed, ref double FrictionBrakeAcceleration)
			{
				if (!Derailed & WheelSpin == 0.0)
				{
					// motor
					if (DecelerationDueToMotor != 0.0)
					{
						double a = -DecelerationDueToMotor;
						if (Specs.CurrentAccelerationOutput > a)
						{
							if (Specs.CurrentAccelerationOutput > 0.0)
							{
								Specs.CurrentAccelerationOutput -= Specs.JerkPowerDown * TimeElapsed;
							}
							else
							{
								Specs.CurrentAccelerationOutput -= Specs.JerkBrakeUp * TimeElapsed;
							}
							if (Specs.CurrentAccelerationOutput < a)
							{
								Specs.CurrentAccelerationOutput = a;
							}
						}
						else
						{
							Specs.CurrentAccelerationOutput += Specs.JerkBrakeDown * TimeElapsed;
							if (Specs.CurrentAccelerationOutput > a)
							{
								Specs.CurrentAccelerationOutput = a;
							}
						}
					}
				}

				base.UpdateBrakeDeceleration(TimeElapsed, ref FrictionBrakeAcceleration);
			}

			internal override void UpdateMotorSounds(double TimeElapsed)
			{
				float speed = (float)Math.Abs(Specs.CurrentPerceivedSpeed);
				int oDir = Sounds.Motor.CurrentAccelerationDirection;
				int nDir = Math.Sign(Specs.CurrentAccelerationOutput);

				if (oDir > 0 & nDir <= 0)
				{
					foreach (MotorSound.Table table in Sounds.Motor.PowerTables)
					{
						Program.Sounds.StopSound(table.PlayingSource);
						table.PlayingSource = null;
						table.PlayingBuffer = null;
					}
				}
				else if (oDir < 0 & nDir >= 0)
				{
					foreach (MotorSound.Table table in Sounds.Motor.BrakeTables)
					{
						Program.Sounds.StopSound(table.PlayingSource);
						table.PlayingSource = null;
						table.PlayingBuffer = null;
					}
				}

				if (nDir != 0)
				{
					MotorSound.Table[] tables = nDir > 0 ? Sounds.Motor.PowerTables : Sounds.Motor.BrakeTables;

					foreach (MotorSound.Table table in tables)
					{
						MotorSound.Entry entry = table.GetEntry(speed);

						if (nDir == 1)
						{
							// power
							double max = Specs.AccelerationCurveMaximum;
							if (max != 0.0)
							{
								double cur = Specs.CurrentAccelerationOutput;
								if (cur < 0.0) cur = 0.0;
								entry.Gain *= Math.Pow(cur / max, 0.25);
							}
						}
						else if (nDir == -1)
						{
							// brake
							double max = CarBrake.DecelerationAtServiceMaximumPressure(baseTrain.Handles.Brake.Actual, CurrentSpeed);
							if (max != 0.0)
							{
								double cur = -Specs.CurrentAccelerationOutput;
								if (cur < 0.0) cur = 0.0;
								entry.Gain *= Math.Pow(cur / max, 0.25);
							}
						}

						if (entry.Buffer != table.PlayingBuffer)
						{
							Program.Sounds.StopSound(table.PlayingSource);
							if (entry.Buffer != null)
							{
								table.PlayingSource = Program.Sounds.PlaySound(entry.Buffer, entry.Pitch, entry.Gain, Sounds.Motor.Position, this, true);
								table.PlayingBuffer = entry.Buffer;
							}
							else
							{
								table.PlayingSource = null;
								table.PlayingBuffer = null;
							}
						}
						else if (entry.Buffer != null)
						{
							if (table.PlayingSource != null)
							{
								table.PlayingSource.Pitch = entry.Pitch;
								table.PlayingSource.Volume = entry.Gain;
							}
						}
						else
						{
							Program.Sounds.StopSound(table.PlayingSource);
							table.PlayingSource = null;
							table.PlayingBuffer = null;
						}
					}
				}

				Sounds.Motor.CurrentAccelerationDirection = nDir;
			}
		}
	}
}
