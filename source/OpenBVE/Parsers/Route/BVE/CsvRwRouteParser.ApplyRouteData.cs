using System;
using System.Collections.Generic;
using OpenBveApi.Colors;
using OpenBveApi.Math;
using OpenBveApi.Runtime;
using OpenBveApi.World;
using OpenBveApi.Interface;
using OpenBveApi.Objects;
using OpenBveApi.FunctionScripting;
using OpenBve.SignalManager;
using OpenBveApi.Textures;
using OpenBveApi.Trains;

namespace OpenBve
{
	internal partial class CsvRwRouteParser
	{
		private static void ApplyRouteData(string FileName, ref RouteData Data, bool PreviewOnly)
		{
			if (CompatibilityObjectsUsed != 0)
			{
				Interface.AddMessage(MessageType.Warning, false, "Warning: " + CompatibilityObjectsUsed + " compatibility objects were used.");
			}
			if (PreviewOnly)
			{
				if (freeObjCount == 0 && railtypeCount == 0)
				{
					throw new Exception(Translations.GetInterfaceString("errors_route_corrupt_noobjects"));
				}
			}
			string LimitGraphicsPath = null;
			
			if (!PreviewOnly)
			{
				CompatibilityObjects.LoadAutoGeneratedObjects(CompatibilityFolder, out LimitGraphicsPath);
			}
			
			// initialize
			System.Globalization.CultureInfo Culture = System.Globalization.CultureInfo.InvariantCulture;
			int LastBlock = (int)Math.Floor((Data.TrackPosition + 600.0) / Data.BlockInterval + 0.001) + 1;
			if (Data.Blocks[Data.Blocks.Length - 1].CurrentTrackState.CurveRadius < 300)
			{
				/*
				 * The track end event is placed 600m after the end of the final block
				 * If our curve radius in the final block is < 300, then our train will
				 * re-appear erroneously if the player is watching the final block
				 */
				Data.Blocks[Data.Blocks.Length - 1].CurrentTrackState.CurveRadius = 0.0;
			}
			int BlocksUsed = Data.Blocks.Length;
			Data.CreateMissingBlocks(ref BlocksUsed, LastBlock, PreviewOnly);
			Array.Resize<Block>(ref Data.Blocks, BlocksUsed);
			// interpolate height
			if (!PreviewOnly)
			{
				int z = 0;
				for (int i = 0; i < Data.Blocks.Length; i++)
				{
					if (!double.IsNaN(Data.Blocks[i].Height))
					{
						for (int j = i - 1; j >= 0; j--)
						{
							if (!double.IsNaN(Data.Blocks[j].Height))
							{
								double a = Data.Blocks[j].Height;
								double b = Data.Blocks[i].Height;
								double d = (b - a) / (double)(i - j);
								for (int k = j + 1; k < i; k++)
								{
									a += d;
									Data.Blocks[k].Height = a;
								}
								break;
							}
						}
						z = i;
					}
				}
				for (int i = z + 1; i < Data.Blocks.Length; i++)
				{
					Data.Blocks[i].Height = Data.Blocks[z].Height;
				}
			}
			// background
			if (!PreviewOnly)
			{
				if (Data.Blocks[0].Background >= 0 & Data.Blocks[0].Background < Data.Backgrounds.Length)
				{
					BackgroundManager.CurrentBackground = Data.Backgrounds[Data.Blocks[0].Background];
				}
				else
				{
					BackgroundManager.CurrentBackground = new BackgroundManager.StaticBackground(null, 6, false);
				}
				BackgroundManager.TargetBackground = BackgroundManager.CurrentBackground;
			}
			// brightness
			int CurrentBrightnessElement = -1;
			int CurrentBrightnessEvent = -1;
			float CurrentBrightnessValue = 1.0f;
			double CurrentBrightnessTrackPosition = (double)Data.FirstUsedBlock * Data.BlockInterval;
			if (!PreviewOnly)
			{
				for (int i = Data.FirstUsedBlock; i < Data.Blocks.Length; i++)
				{
					if (Data.Blocks[i].BrightnessChanges != null && Data.Blocks[i].BrightnessChanges.Length != 0)
					{
						CurrentBrightnessValue = Data.Blocks[i].BrightnessChanges[0].Value;
						CurrentBrightnessTrackPosition = Data.Blocks[i].BrightnessChanges[0].Value;
						break;
					}
				}
			}
			// create objects and track
			Vector3 Position = Vector3.Zero;
			Vector2 Direction = new Vector2(0.0, 1.0);
			double CurrentSpeedLimit = double.PositiveInfinity;
			int CurrentRunIndex = 0;
			int CurrentFlangeIndex = 0;
			if (Data.FirstUsedBlock < 0) Data.FirstUsedBlock = 0;
			int CurrentTrackLength = 0;
			int PreviousFogElement = -1;
			int PreviousFogEvent = -1;
			Game.Fog PreviousFog = new Game.Fog(Game.NoFogStart, Game.NoFogEnd, Color24.Grey, -Data.BlockInterval);
			Game.Fog CurrentFog = new Game.Fog(Game.NoFogStart, Game.NoFogEnd, Color24.Grey, 0.0);
			for (int i = Data.FirstUsedBlock; i < Data.Blocks.Length; i++)
			{
				if (Data.Blocks[i].Rails.Length > TrackManager.Tracks.Length)
				{
					Array.Resize(ref TrackManager.Tracks, Data.Blocks[i].Rails.Length);
				}
			}
			for (int i = 0; i < TrackManager.Tracks.Length; i++)
			{
				if (TrackManager.Tracks[i].Elements == null)
				{
					TrackManager.Tracks[i].Elements = new TrackManager.TrackElement[256];
				}
			}
			// process blocks
			double progressFactor = Data.Blocks.Length - Data.FirstUsedBlock == 0 ? 0.5 : 0.5 / (double)(Data.Blocks.Length - Data.FirstUsedBlock);
			for (int i = Data.FirstUsedBlock; i < Data.Blocks.Length; i++)
			{
				Loading.RouteProgress = 0.6667 + (double)(i - Data.FirstUsedBlock) * progressFactor;
				if ((i & 15) == 0)
				{
					System.Threading.Thread.Sleep(1);
					if (Loading.Cancel) return;
				}
				double StartingDistance = (double)i * Data.BlockInterval;
				double EndingDistance = StartingDistance + Data.BlockInterval;
				// normalize
				Direction.Normalize();
				// track
				if (!PreviewOnly)
				{
					if (Data.Blocks[i].Cycle.Length == 1 && Data.Blocks[i].Cycle[0] == -1)
					{
						if (Data.Structure.Cycles.Length == 0 || Data.Structure.Cycles[0] == null)
						{
							Data.Blocks[i].Cycle = new int[] { 0 };
						}
						else
						{
							Data.Blocks[i].Cycle = Data.Structure.Cycles[0];
						}
					}
				}
				TrackManager.TrackElement WorldTrackElement = Data.Blocks[i].CurrentTrackState;
				int n = CurrentTrackLength;
				for (int j = 0; j < TrackManager.Tracks.Length; j++)
				{
					if (n >= TrackManager.Tracks[j].Elements.Length)
					{
						Array.Resize<TrackManager.TrackElement>(ref TrackManager.Tracks[j].Elements, TrackManager.Tracks[j].Elements.Length << 1);
					}
				}
				CurrentTrackLength++;
				TrackManager.Tracks[0].Elements[n] = WorldTrackElement;
				TrackManager.Tracks[0].Elements[n].WorldPosition = Position;
				TrackManager.Tracks[0].Elements[n].WorldDirection = Vector3.GetVector3(Direction, Data.Blocks[i].Pitch);
				TrackManager.Tracks[0].Elements[n].WorldSide = new Vector3(Direction.Y, 0.0, -Direction.X);
				TrackManager.Tracks[0].Elements[n].WorldUp = Vector3.Cross(TrackManager.Tracks[0].Elements[n].WorldDirection, TrackManager.Tracks[0].Elements[n].WorldSide);
				TrackManager.Tracks[0].Elements[n].StartingTrackPosition = StartingDistance;
				TrackManager.Tracks[0].Elements[n].AdhesionMultiplier = Data.Blocks[i].AdhesionMultiplier;
				TrackManager.Tracks[0].Elements[n].CsvRwAccuracyLevel = Data.Blocks[i].Accuracy;
				for (int j = 0; j < TrackManager.Tracks.Length; j++)
				{
					TrackManager.Tracks[j].Elements[n].Events = new TrackManager.GeneralEvent[] { };
				}
				// background
				if (!PreviewOnly)
				{
					if (Data.Blocks[i].Background >= 0)
					{
						int typ;
						if (i == Data.FirstUsedBlock)
						{
							typ = Data.Blocks[i].Background;
						}
						else
						{
							typ = Data.Backgrounds.Length > 0 ? 0 : -1;
							for (int j = i - 1; j >= Data.FirstUsedBlock; j--)
							{
								if (Data.Blocks[j].Background >= 0)
								{
									typ = Data.Blocks[j].Background;
									break;
								}
							}
						}
						if (typ >= 0 & typ < Data.Backgrounds.Length)
						{
							int m = TrackManager.Tracks[0].Elements[n].Events.Length;
							Array.Resize<TrackManager.GeneralEvent>(ref TrackManager.Tracks[0].Elements[n].Events, m + 1);
							TrackManager.Tracks[0].Elements[n].Events[m] = new TrackManager.BackgroundChangeEvent(0.0, Data.Backgrounds[typ], Data.Backgrounds[Data.Blocks[i].Background]);
						}
					}
				}
				// brightness
				if (!PreviewOnly)
				{
					for (int j = 0; j < Data.Blocks[i].BrightnessChanges.Length; j++)
					{
						/*
						 * Legacy brightness: This applies equally to all tracks in a block
						 */
						for (int t = 0; t < TrackManager.Tracks.Length; t++)
						{
							int m = TrackManager.Tracks[t].Elements[n].Events.Length;
							Array.Resize<TrackManager.GeneralEvent>(ref TrackManager.Tracks[t].Elements[n].Events, m + 1);
							double d = Data.Blocks[i].BrightnessChanges[j].TrackPosition - StartingDistance;
							TrackManager.Tracks[t].Elements[n].Events[m] = new TrackManager.BrightnessChangeEvent(d, Data.Blocks[i].BrightnessChanges[j].Value, CurrentBrightnessValue, Data.Blocks[i].BrightnessChanges[j].TrackPosition - CurrentBrightnessTrackPosition);
							
							if (t == 0)
							{
								if (CurrentBrightnessElement >= 0 & CurrentBrightnessEvent >= 0)
								{
									TrackManager.BrightnessChangeEvent bce = (TrackManager.BrightnessChangeEvent)TrackManager.Tracks[t].Elements[CurrentBrightnessElement].Events[CurrentBrightnessEvent];
									bce.NextBrightness = Data.Blocks[i].BrightnessChanges[j].Value;
									bce.NextDistance = Data.Blocks[i].BrightnessChanges[j].TrackPosition - CurrentBrightnessTrackPosition;
								}
								CurrentBrightnessEvent = m;
								
							}
							else
							{
								if (CurrentBrightnessElement >= 0 & CurrentBrightnessEvent >= 0)
								{
									for (int e = 0; e < TrackManager.Tracks[t].Elements[CurrentBrightnessElement].Events.Length; e++)
									{
										if (!(TrackManager.Tracks[t].Elements[CurrentBrightnessElement].Events[e] is TrackManager.BrightnessChangeEvent))
											continue;
										TrackManager.BrightnessChangeEvent bce = (TrackManager.BrightnessChangeEvent)TrackManager.Tracks[t].Elements[CurrentBrightnessElement].Events[e];
										bce.NextBrightness = Data.Blocks[i].BrightnessChanges[j].Value;
										bce.NextDistance = Data.Blocks[i].BrightnessChanges[j].TrackPosition - CurrentBrightnessTrackPosition;
									}
								}
							}
						}
						CurrentBrightnessElement = n;
						CurrentBrightnessTrackPosition = Data.Blocks[i].BrightnessChanges[j].TrackPosition;
						CurrentBrightnessValue = Data.Blocks[i].BrightnessChanges[j].Value;
					}
				}
				// fog
				if (!PreviewOnly)
				{
					if (Data.FogTransitionMode)
					{
						if (Data.Blocks[i].FogDefined)
						{
							if (i == 0 && StartingDistance == 0)
							{
								//Fog starts at zero position
								PreviousFog = Data.Blocks[i].Fog;
							}
							Data.Blocks[i].Fog.TrackPosition = StartingDistance;
							int m = TrackManager.Tracks[0].Elements[n].Events.Length;
							Array.Resize<TrackManager.GeneralEvent>(ref TrackManager.Tracks[0].Elements[n].Events, m + 1);
							TrackManager.Tracks[0].Elements[n].Events[m] = new TrackManager.FogChangeEvent(0.0, PreviousFog, Data.Blocks[i].Fog, Data.Blocks[i].Fog);
							if (PreviousFogElement >= 0 & PreviousFogEvent >= 0)
							{
								TrackManager.FogChangeEvent e = (TrackManager.FogChangeEvent)TrackManager.Tracks[0].Elements[PreviousFogElement].Events[PreviousFogEvent];
								e.NextFog = Data.Blocks[i].Fog;
							}
							else
							{
								Game.PreviousFog = PreviousFog;
								Game.CurrentFog = PreviousFog;
								Game.NextFog = Data.Blocks[i].Fog;
							}
							PreviousFog = Data.Blocks[i].Fog;
							PreviousFogElement = n;
							PreviousFogEvent = m;
						}
					}
					else
					{
						if (i == 0 && StartingDistance == 0)
						{
							//Fog starts at zero position
							CurrentFog = Data.Blocks[i].Fog;
							PreviousFog = CurrentFog;
							Game.PreviousFog = CurrentFog;
							Game.CurrentFog = CurrentFog;
							Game.NextFog = CurrentFog;


						}
						else
						{
							Data.Blocks[i].Fog.TrackPosition = StartingDistance + Data.BlockInterval;
							int m = TrackManager.Tracks[0].Elements[n].Events.Length;
							Array.Resize<TrackManager.GeneralEvent>(ref TrackManager.Tracks[0].Elements[n].Events, m + 1);
							TrackManager.Tracks[0].Elements[n].Events[m] = new TrackManager.FogChangeEvent(0.0, PreviousFog, CurrentFog, Data.Blocks[i].Fog);
							PreviousFog = CurrentFog;
							CurrentFog = Data.Blocks[i].Fog;
						}
					}
				}
				// rail sounds
				if (!PreviewOnly)
				{
					int j = Data.Blocks[i].RailType[0];
					int r = j < Data.Structure.Run.Length ? Data.Structure.Run[j] : 0;
					int f = j < Data.Structure.Flange.Length ? Data.Structure.Flange[j] : 0;
					int m = TrackManager.Tracks[0].Elements[n].Events.Length;
					Array.Resize<TrackManager.GeneralEvent>(ref TrackManager.Tracks[0].Elements[n].Events, m + 1);
					TrackManager.Tracks[0].Elements[n].Events[m] = new TrackManager.RailSoundsChangeEvent(0.0, CurrentRunIndex, CurrentFlangeIndex, r, f);
					CurrentRunIndex = r;
					CurrentFlangeIndex = f;
				}
				// point sound
				if (!PreviewOnly)
				{
					if (i < Data.Blocks.Length - 1)
					{
						for (int j = 0; j < Data.Blocks[i].Rails.Length; j++)
						{
							if (Data.Blocks[i].Rails[j].RailStarted & Data.Blocks[i + 1].Rails.Length > j)
							{
								bool q = false;
								for (int k = 0; k < Data.Blocks[i].Rails.Length; k++)
								{
									if (Data.Blocks[i].Rails[k].RailStarted & Data.Blocks[i + 1].Rails.Length > k)
									{
										bool qx = Math.Sign(Data.Blocks[i].Rails[k].RailStart.X - Data.Blocks[i].Rails[j].RailStart.X) != Math.Sign(Data.Blocks[i + 1].Rails[k].RailEnd.X - Data.Blocks[i + 1].Rails[j].RailEnd.X);
										bool qy = (Data.Blocks[i].Rails[k].RailStart.Y - Data.Blocks[i].Rails[j].RailStart.Y) * (Data.Blocks[i + 1].Rails[k].RailEnd.Y - Data.Blocks[i + 1].Rails[j].RailEnd.Y) <= 0.0;
										if (qx & qy)
										{
											q = true;
											break;
										}
									}
								}
								if (q)
								{
									int m = TrackManager.Tracks[j].Elements[n].Events.Length;
									Array.Resize<TrackManager.GeneralEvent>(ref TrackManager.Tracks[j].Elements[n].Events, m + 1);
									TrackManager.Tracks[j].Elements[n].Events[m] = new TrackManager.PointSoundEvent(12.5);
								}
							}
						}
					}
				}
				// station
				if (Data.Blocks[i].Station >= 0)
				{
					// station
					int s = Data.Blocks[i].Station;
					int m = TrackManager.Tracks[0].Elements[n].Events.Length;
					Array.Resize<TrackManager.GeneralEvent>(ref TrackManager.Tracks[0].Elements[n].Events, m + 1);
					TrackManager.Tracks[0].Elements[n].Events[m] = new TrackManager.StationStartEvent(0.0, s);
					double dx, dy = 3.0;
					if (Game.Stations[s].OpenLeftDoors & !Game.Stations[s].OpenRightDoors)
					{
						dx = -5.0;
					}
					else if (!Game.Stations[s].OpenLeftDoors & Game.Stations[s].OpenRightDoors)
					{
						dx = 5.0;
					}
					else
					{
						dx = 0.0;
					}
					Game.Stations[s].SoundOrigin = Position + dx * TrackManager.Tracks[0].Elements[n].WorldSide + dy * TrackManager.Tracks[0].Elements[n].WorldUp;
					// passalarm
					if (!PreviewOnly)
					{
						if (Data.Blocks[i].StationPassAlarm)
						{
							int b = i - 6;
							if (b >= 0)
							{
								int j = b - Data.FirstUsedBlock;
								if (j >= 0)
								{
									m = TrackManager.Tracks[0].Elements[j].Events.Length;
									Array.Resize<TrackManager.GeneralEvent>(ref TrackManager.Tracks[0].Elements[j].Events, m + 1);
									TrackManager.Tracks[0].Elements[j].Events[m] = new TrackManager.StationPassAlarmEvent(0.0);
								}
							}
						}
					}
				}
				// stop
				for (int j = 0; j < Data.Blocks[i].StopPositions.Length; j++)
				{
					int s = Data.Blocks[i].StopPositions[j].Station;
					int t = Game.Stations[s].Stops.Length;
					Array.Resize<Game.StationStop>(ref Game.Stations[s].Stops, t + 1);
					Game.Stations[s].Stops[t].TrackPosition = Data.Blocks[i].StopPositions[j].TrackPosition;
					Game.Stations[s].Stops[t].ForwardTolerance = Data.Blocks[i].StopPositions[j].ForwardTolerance;
					Game.Stations[s].Stops[t].BackwardTolerance = Data.Blocks[i].StopPositions[j].BackwardTolerance;
					Game.Stations[s].Stops[t].Cars = Data.Blocks[i].StopPositions[j].Cars;
					double dx, dy = 2.0;
					if (Game.Stations[s].OpenLeftDoors & !Game.Stations[s].OpenRightDoors)
					{
						dx = -5.0;
					}
					else if (!Game.Stations[s].OpenLeftDoors & Game.Stations[s].OpenRightDoors)
					{
						dx = 5.0;
					}
					else
					{
						dx = 0.0;
					}

					Game.Stations[s].SoundOrigin = Position + dx * TrackManager.Tracks[0].Elements[n].WorldSide + dy * TrackManager.Tracks[0].Elements[n].WorldUp;
				}
				// limit
				for (int j = 0; j < Data.Blocks[i].Limits.Length; j++)
				{
					int m = TrackManager.Tracks[0].Elements[n].Events.Length;
					Array.Resize<TrackManager.GeneralEvent>(ref TrackManager.Tracks[0].Elements[n].Events, m + 1);
					double d = Data.Blocks[i].Limits[j].TrackPosition - StartingDistance;
					TrackManager.Tracks[0].Elements[n].Events[m] = new TrackManager.LimitChangeEvent(d, CurrentSpeedLimit, Data.Blocks[i].Limits[j].Speed);
					CurrentSpeedLimit = Data.Blocks[i].Limits[j].Speed;
				}
				// marker
				if (!PreviewOnly)
				{
					for (int j = 0; j < Data.Markers.Length; j++)
					{
						if (Data.Markers[j].StartingPosition >= StartingDistance & Data.Markers[j].StartingPosition < EndingDistance)
						{
							int m = TrackManager.Tracks[0].Elements[n].Events.Length;
							Array.Resize<TrackManager.GeneralEvent>(ref TrackManager.Tracks[0].Elements[n].Events, m + 1);
							double d = Data.Markers[j].StartingPosition - StartingDistance;
							if (Data.Markers[j].Message != null)
							{
								TrackManager.Tracks[0].Elements[n].Events[m] = new TrackManager.MarkerStartEvent(d, Data.Markers[j].Message);
							}
						}
						if (Data.Markers[j].EndingPosition >= StartingDistance & Data.Markers[j].EndingPosition < EndingDistance)
						{
							int m = TrackManager.Tracks[0].Elements[n].Events.Length;
							Array.Resize<TrackManager.GeneralEvent>(ref TrackManager.Tracks[0].Elements[n].Events, m + 1);
							double d = Data.Markers[j].EndingPosition - StartingDistance;
							if (Data.Markers[j].Message != null)
							{
								TrackManager.Tracks[0].Elements[n].Events[m] = new TrackManager.MarkerEndEvent(d, Data.Markers[j].Message);
							}
						}
					}
				}
				// sound
				if (!PreviewOnly)
				{
					for (int j = 0; j < Data.Blocks[i].SoundEvents.Length; j++)
					{
						if (Data.Blocks[i].SoundEvents[j].Type == SoundType.TrainStatic | Data.Blocks[i].SoundEvents[j].Type == SoundType.TrainDynamic)
						{
							int m = TrackManager.Tracks[0].Elements[n].Events.Length;
							Array.Resize<TrackManager.GeneralEvent>(ref TrackManager.Tracks[0].Elements[n].Events, m + 1);
							double d = Data.Blocks[i].SoundEvents[j].TrackPosition - StartingDistance;
							switch (Data.Blocks[i].SoundEvents[j].Type)
							{
								case SoundType.TrainStatic:
									TrackManager.Tracks[0].Elements[n].Events[m] = new TrackManager.SoundEvent(d, Data.Blocks[i].SoundEvents[j].SoundBuffer, true, true, false, Vector3.Zero, 0.0);
									break;
								case SoundType.TrainDynamic:
									TrackManager.Tracks[0].Elements[n].Events[m] = new TrackManager.SoundEvent(d, Data.Blocks[i].SoundEvents[j].SoundBuffer, false, false, true, Vector3.Zero, Data.Blocks[i].SoundEvents[j].Speed);
									break;
							}
						}
					}
				}
				// turn
				if (Data.Blocks[i].Turn != 0.0)
				{
					double ag = -Math.Atan(Data.Blocks[i].Turn);
					double cosag = Math.Cos(ag);
					double sinag = Math.Sin(ag);
					Direction.Rotate(cosag, sinag);
					TrackManager.Tracks[0].Elements[n].WorldDirection.RotatePlane(cosag, sinag);
					TrackManager.Tracks[0].Elements[n].WorldSide.RotatePlane(cosag, sinag);
					TrackManager.Tracks[0].Elements[n].WorldUp = Vector3.Cross(TrackManager.Tracks[0].Elements[n].WorldDirection, TrackManager.Tracks[0].Elements[n].WorldSide);
				}
				//Pitch
				if (Data.Blocks[i].Pitch != 0.0)
				{
					TrackManager.Tracks[0].Elements[n].Pitch = Data.Blocks[i].Pitch;
				}
				else
				{
					TrackManager.Tracks[0].Elements[n].Pitch = 0.0;
				}
				// curves
				double a = 0.0;
				double c = Data.BlockInterval;
				double h = 0.0;
				if (WorldTrackElement.CurveRadius != 0.0 & Data.Blocks[i].Pitch != 0.0)
				{
					double d = Data.BlockInterval;
					double p = Data.Blocks[i].Pitch;
					double r = WorldTrackElement.CurveRadius;
					double s = d / Math.Sqrt(1.0 + p * p);
					h = s * p;
					double b = s / Math.Abs(r);
					c = Math.Sqrt(2.0 * r * r * (1.0 - Math.Cos(b)));
					a = 0.5 * (double)Math.Sign(r) * b;
					Direction.Rotate(Math.Cos(-a), Math.Sin(-a));
				}
				else if (WorldTrackElement.CurveRadius != 0.0)
				{
					double d = Data.BlockInterval;
					double r = WorldTrackElement.CurveRadius;
					double b = d / Math.Abs(r);
					c = Math.Sqrt(2.0 * r * r * (1.0 - Math.Cos(b)));
					a = 0.5 * (double)Math.Sign(r) * b;
					Direction.Rotate(Math.Cos(-a), Math.Sin(-a));
				}
				else if (Data.Blocks[i].Pitch != 0.0)
				{
					double p = Data.Blocks[i].Pitch;
					double d = Data.BlockInterval;
					c = d / Math.Sqrt(1.0 + p * p);
					h = c * p;
				}
				double TrackYaw = Math.Atan2(Direction.X, Direction.Y);
				double TrackPitch = Math.Atan(Data.Blocks[i].Pitch);
				Transformation GroundTransformation = new Transformation(TrackYaw, 0.0, 0.0);
				Transformation TrackTransformation = new Transformation(TrackYaw, TrackPitch, 0.0);
				Transformation NullTransformation = new Transformation(0.0, 0.0, 0.0);
				// ground
				if (!PreviewOnly)
				{
					int cb = (int)Math.Floor((double)i + 0.001);
					int ci = (cb % Data.Blocks[i].Cycle.Length + Data.Blocks[i].Cycle.Length) % Data.Blocks[i].Cycle.Length;
					int gi = Data.Blocks[i].Cycle[ci];
					if (gi >= 0 & Data.Structure.Ground.ContainsKey(gi))
					{
						Data.Structure.Ground[Data.Blocks[i].Cycle[ci]].CreateObject(Position + new Vector3(0.0, -Data.Blocks[i].Height, 0.0), GroundTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
					}
				}
				// ground-aligned free objects
				if (!PreviewOnly)
				{
					for (int j = 0; j < Data.Blocks[i].GroundFreeObj.Length; j++)
					{
						int sttype = Data.Blocks[i].GroundFreeObj[j].Type;
						double d = Data.Blocks[i].GroundFreeObj[j].TrackPosition - StartingDistance;
						double dx = Data.Blocks[i].GroundFreeObj[j].Position.X;
						double dy = Data.Blocks[i].GroundFreeObj[j].Position.Y;
						Vector3 wpos = Position + new Vector3(Direction.X * d + Direction.Y * dx, dy - Data.Blocks[i].Height, Direction.Y * d - Direction.X * dx);
						double tpos = Data.Blocks[i].GroundFreeObj[j].TrackPosition;
						Data.Structure.FreeObjects[sttype].CreateObject(wpos, GroundTransformation, new Transformation(Data.Blocks[i].GroundFreeObj[j].Yaw, Data.Blocks[i].GroundFreeObj[j].Pitch, Data.Blocks[i].GroundFreeObj[j].Roll), Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, tpos);
					}
				}
				// rail-aligned objects
				if (!PreviewOnly)
				{
					for (int j = 0; j < Data.Blocks[i].Rails.Length; j++)
					{
						if (j > 0 && !Data.Blocks[i].Rails[j].RailStarted) continue;
						// rail
						Vector3 pos;
						Transformation RailTransformation;
						double planar, updown;
						if (j == 0)
						{
							// rail 0
							planar = 0.0;
							updown = 0.0;
							RailTransformation = new Transformation(TrackTransformation, planar, updown, 0.0);
							pos = Position;
						}
						else
						{
							// rails 1-infinity
							double x = Data.Blocks[i].Rails[j].RailStart.X;
							double y = Data.Blocks[i].Rails[j].RailStart.Y;
							Vector3 offset = new Vector3(Direction.Y * x, y, -Direction.X * x);
							pos = Position + offset;
							double dh;
							if (i < Data.Blocks.Length - 1 && Data.Blocks[i + 1].Rails.Length > j)
							{
								// take orientation of upcoming block into account
								Vector2 Direction2 = Direction;
								Vector3 Position2 = Position;
								Position2.X += Direction.X * c;
								Position2.Y += h;
								Position2.Z += Direction.Y * c;
								if (a != 0.0)
								{
									Direction2.Rotate(Math.Cos(-a), Math.Sin(-a));
								}
								if (Data.Blocks[i + 1].Turn != 0.0)
								{
									double ag = -Math.Atan(Data.Blocks[i + 1].Turn);
									double cosag = Math.Cos(ag);
									double sinag = Math.Sin(ag);
									Direction2.Rotate(cosag, sinag);
								}
								double a2;
								// double c2 = Data.BlockInterval;
								// double h2 = 0.0;
								if (Data.Blocks[i + 1].CurrentTrackState.CurveRadius != 0.0 & Data.Blocks[i + 1].Pitch != 0.0)
								{
									double d2 = Data.BlockInterval;
									double p2 = Data.Blocks[i + 1].Pitch;
									double r2 = Data.Blocks[i + 1].CurrentTrackState.CurveRadius;
									double s2 = d2 / Math.Sqrt(1.0 + p2 * p2);
									// h2 = s2 * p2;
									double b2 = s2 / Math.Abs(r2);
									// c2 = Math.Sqrt(2.0 * r2 * r2 * (1.0 - Math.Cos(b2)));
									a2 = 0.5 * (double)Math.Sign(r2) * b2;
									Direction2.Rotate(Math.Cos(-a2), Math.Sin(-a2));
								}
								else if (Data.Blocks[i + 1].CurrentTrackState.CurveRadius != 0.0)
								{
									double d2 = Data.BlockInterval;
									double r2 = Data.Blocks[i + 1].CurrentTrackState.CurveRadius;
									double b2 = d2 / Math.Abs(r2);
									// c2 = Math.Sqrt(2.0 * r2 * r2 * (1.0 - Math.Cos(b2)));
									a2 = 0.5 * (double)Math.Sign(r2) * b2;
									Direction2.Rotate(Math.Cos(-a2), Math.Sin(-a2));
								}
								// else if (Data.Blocks[i + 1].Pitch != 0.0) {
								// double p2 = Data.Blocks[i + 1].Pitch;
								// double d2 = Data.BlockInterval;
								// c2 = d2 / Math.Sqrt(1.0 + p2 * p2);
								// h2 = c2 * p2;
								// }

								//These generate a compiler warning, as secondary tracks do not generate yaw, as they have no
								//concept of a curve, but rather are a straight line between two points
								//TODO: Revist the handling of secondary tracks ==> !!BACKWARDS INCOMPATIBLE!!
								/*
								double TrackYaw2 = Math.Atan2(Direction2.X, Direction2.Y);
								double TrackPitch2 = Math.Atan(Data.Blocks[i + 1].Pitch);
								Transformation GroundTransformation2 = new Transformation(TrackYaw2, 0.0, 0.0);
								Transformation TrackTransformation2 = new Transformation(TrackYaw2, TrackPitch2, 0.0);
								 */
								double x2 = Data.Blocks[i + 1].Rails[j].RailEnd.X;
								double y2 = Data.Blocks[i + 1].Rails[j].RailEnd.Y;
								Vector3 offset2 = new Vector3(Direction2.Y * x2, y2, -Direction2.X * x2);
								Vector3 pos2 = Position2 + offset2;
								Vector3 r = new Vector3(pos2.X - pos.X, pos2.Y - pos.Y, pos2.Z - pos.Z);
								r.Normalize();
								RailTransformation.Z = r;
								RailTransformation.X = new Vector3(r.Z, 0.0, -r.X);
								World.Normalize(ref RailTransformation.X.X, ref RailTransformation.X.Z);
								RailTransformation.Y = Vector3.Cross(RailTransformation.Z, RailTransformation.X);
								double dx = Data.Blocks[i + 1].Rails[j].RailEnd.X - Data.Blocks[i].Rails[j].RailStart.X;
								double dy = Data.Blocks[i + 1].Rails[j].RailEnd.Y - Data.Blocks[i].Rails[j].RailStart.Y;
								planar = Math.Atan(dx / c);
								dh = dy / c;
								updown = Math.Atan(dh);
							}
							else
							{
								planar = 0.0;
								dh = 0.0;
								updown = 0.0;
								RailTransformation = new Transformation(TrackTransformation, 0.0, 0.0, 0.0);
							}

							TrackManager.Tracks[j].Elements[n].StartingTrackPosition = StartingDistance;
							TrackManager.Tracks[j].Elements[n].WorldPosition = pos;
							TrackManager.Tracks[j].Elements[n].WorldDirection = RailTransformation.Z;
							TrackManager.Tracks[j].Elements[n].WorldSide = RailTransformation.X;
							TrackManager.Tracks[j].Elements[n].WorldUp = RailTransformation.Y;
							TrackManager.Tracks[j].Elements[n].CurveCant = Data.Blocks[i].Rails[j].CurveCant;
							TrackManager.Tracks[j].Elements[n].AdhesionMultiplier = Data.Blocks[i].AdhesionMultiplier;
						}
						if (Data.Structure.RailObjects.ContainsKey(Data.Blocks[i].RailType[j]))
						{
							if (Data.Structure.RailObjects[Data.Blocks[i].RailType[j]] != null)
							{
								Data.Structure.RailObjects[Data.Blocks[i].RailType[j]].CreateObject(pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
							}
						}
						// points of interest
						for (int k = 0; k < Data.Blocks[i].PointsOfInterest.Length; k++)
						{
							if (Data.Blocks[i].PointsOfInterest[k].RailIndex == j)
							{
								double d = Data.Blocks[i].PointsOfInterest[k].TrackPosition - StartingDistance;
								double x = Data.Blocks[i].PointsOfInterest[k].Position.X;
								double y = Data.Blocks[i].PointsOfInterest[k].Position.Y;
								int m = Game.PointsOfInterest.Length;
								Array.Resize<Game.PointOfInterest>(ref Game.PointsOfInterest, m + 1);
								Game.PointsOfInterest[m].TrackPosition = Data.Blocks[i].PointsOfInterest[k].TrackPosition;
								if (i < Data.Blocks.Length - 1 && Data.Blocks[i + 1].Rails.Length > j)
								{
									double dx = Data.Blocks[i + 1].Rails[j].RailEnd.X - Data.Blocks[i].Rails[j].RailStart.X;
									double dy = Data.Blocks[i + 1].Rails[j].RailEnd.Y - Data.Blocks[i].Rails[j].RailStart.Y;
									dx = Data.Blocks[i].Rails[j].RailStart.X + d / Data.BlockInterval * dx;
									dy = Data.Blocks[i].Rails[j].RailStart.Y + d / Data.BlockInterval * dy;
									Game.PointsOfInterest[m].TrackOffset = new Vector3(x + dx, y + dy, 0.0);
								}
								else
								{
									double dx = Data.Blocks[i].Rails[j].RailStart.X;
									double dy = Data.Blocks[i].Rails[j].RailStart.Y;
									Game.PointsOfInterest[m].TrackOffset = new Vector3(x + dx, y + dy, 0.0);
								}
								Game.PointsOfInterest[m].TrackYaw = Data.Blocks[i].PointsOfInterest[k].Yaw + planar;
								Game.PointsOfInterest[m].TrackPitch = Data.Blocks[i].PointsOfInterest[k].Pitch + updown;
								Game.PointsOfInterest[m].TrackRoll = Data.Blocks[i].PointsOfInterest[k].Roll;
								Game.PointsOfInterest[m].Text = Data.Blocks[i].PointsOfInterest[k].Text;
							}
						}
						// poles
						if (Data.Blocks[i].RailPole.Length > j && Data.Blocks[i].RailPole[j].Exists)
						{
							double dz = StartingDistance / Data.Blocks[i].RailPole[j].Interval;
							dz -= Math.Floor(dz + 0.5);
							if (dz >= -0.01 & dz <= 0.01)
							{
								if (Data.Blocks[i].RailPole[j].Mode == 0)
								{
									if (Data.Blocks[i].RailPole[j].Location <= 0.0)
									{
										Data.Structure.Poles[0][Data.Blocks[i].RailPole[j].Type].CreateObject(pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
									}
									else
									{
										UnifiedObject Pole = GetMirroredObject(Data.Structure.Poles[0][Data.Blocks[i].RailPole[j].Type]);
										Pole.CreateObject(pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
									}
								}
								else
								{
									int m = Data.Blocks[i].RailPole[j].Mode;
									double dx = -Data.Blocks[i].RailPole[j].Location * 3.8;
									double wa = Math.Atan2(Direction.Y, Direction.X) - planar;
									Vector3 w = new Vector3(Math.Cos(wa), Math.Tan(updown), Math.Sin(wa));
									w.Normalize();
									double sx = Direction.Y;
									double sy = 0.0;
									double sz = -Direction.X;
									Vector3 wpos = pos + new Vector3(sx * dx + w.X * dz, sy * dx + w.Y * dz, sz * dx + w.Z * dz);
									int type = Data.Blocks[i].RailPole[j].Type;
									Data.Structure.Poles[m][type].CreateObject(wpos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
								}
							}
						}
						// walls
						if (Data.Blocks[i].RailWall.Length > j && Data.Blocks[i].RailWall[j].Exists)
						{
							if (Data.Blocks[i].RailWall[j].Direction <= 0)
							{
								Data.Structure.WallL[Data.Blocks[i].RailWall[j].Type].CreateObject(pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
							}
							if (Data.Blocks[i].RailWall[j].Direction >= 0)
							{
								Data.Structure.WallR[Data.Blocks[i].RailWall[j].Type].CreateObject(pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
							}
						}
						// dikes
						if (Data.Blocks[i].RailDike.Length > j && Data.Blocks[i].RailDike[j].Exists)
						{
							if (Data.Blocks[i].RailDike[j].Direction <= 0)
							{
								Data.Structure.DikeL[Data.Blocks[i].RailDike[j].Type].CreateObject(pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
							}
							if (Data.Blocks[i].RailDike[j].Direction >= 0)
							{
								Data.Structure.DikeR[Data.Blocks[i].RailDike[j].Type].CreateObject(pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
							}
						}
						// sounds
						if (j == 0)
						{
							for (int k = 0; k < Data.Blocks[i].SoundEvents.Length; k++)
							{
								if (Data.Blocks[i].SoundEvents[k].Type == SoundType.World)
								{
									if (Data.Blocks[i].SoundEvents[k].SoundBuffer != null || Data.Blocks[i].SoundEvents[k].IsMicSound)
									{
										var SoundEvent = Data.Blocks[i].SoundEvents[k];
										double d = SoundEvent.TrackPosition - StartingDistance;
										double dx = SoundEvent.Position.X;
										double dy = SoundEvent.Position.Y;
										double wa = Math.Atan2(Direction.Y, Direction.X) - planar;
										Vector3 w = new Vector3(Math.Cos(wa), Math.Tan(updown), Math.Sin(wa));
										w.Normalize();
										Vector3 s = new Vector3(Direction.Y, 0.0, -Direction.X);
										Vector3 u = Vector3.Cross(w, s);
										Vector3 wpos = pos + new Vector3(s.X * dx + u.X * dy + w.X * d, s.Y * dx + u.Y * dy + w.Y * d, s.Z * dx + u.Z * dy + w.Z * d);
										if (SoundEvent.IsMicSound)
										{
											Sounds.PlayMicSound(wpos, SoundEvent.BackwardTolerance, SoundEvent.ForwardTolerance);
										}
										else
										{
											Sounds.PlaySound(SoundEvent.SoundBuffer, 1.0, 1.0, wpos, true);
										}
									}
								}
							}
						}
						// forms
						for (int k = 0; k < Data.Blocks[i].Forms.Length; k++)
						{
							// primary rail
							if (Data.Blocks[i].Forms[k].PrimaryRail == j)
							{
								if (Data.Blocks[i].Forms[k].SecondaryRail == Form.SecondaryRailStub)
								{
									if (!Data.Structure.FormL.ContainsKey(Data.Blocks[i].Forms[k].FormType))
									{
										Interface.AddMessage(MessageType.Error, false, "FormStructureIndex references a FormL not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
									}
									else
									{
										Data.Structure.FormL[Data.Blocks[i].Forms[k].FormType].CreateObject(pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
										if (Data.Blocks[i].Forms[k].RoofType > 0)
										{
											if (!Data.Structure.RoofL.ContainsKey(Data.Blocks[i].Forms[k].RoofType))
											{
												Interface.AddMessage(MessageType.Error, false, "RoofStructureIndex references a RoofL not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
											}
											else
											{
												Data.Structure.RoofL[Data.Blocks[i].Forms[k].RoofType].CreateObject(pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
											}
										}
									}
								}
								else if (Data.Blocks[i].Forms[k].SecondaryRail == Form.SecondaryRailL)
								{
									if (!Data.Structure.FormL.ContainsKey(Data.Blocks[i].Forms[k].FormType))
									{
										Interface.AddMessage(MessageType.Error, false, "FormStructureIndex references a FormL not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
									}
									else
									{
										Data.Structure.FormL[Data.Blocks[i].Forms[k].FormType].CreateObject(pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
									}
									if (!Data.Structure.FormCL.ContainsKey(Data.Blocks[i].Forms[k].FormType))
									{
										Interface.AddMessage(MessageType.Error, false, "FormStructureIndex references a FormCL not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
									}
									else
									{
										ObjectManager.CreateStaticObject((StaticObject)Data.Structure.FormCL[Data.Blocks[i].Forms[k].FormType], pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
									}
									if (Data.Blocks[i].Forms[k].RoofType > 0)
									{
										if (!Data.Structure.RoofL.ContainsKey(Data.Blocks[i].Forms[k].RoofType))
										{
											Interface.AddMessage(MessageType.Error, false, "RoofStructureIndex references a RoofL not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
										}
										else
										{
											Data.Structure.RoofL[Data.Blocks[i].Forms[k].RoofType].CreateObject(pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
										}
										if (!Data.Structure.RoofCL.ContainsKey(Data.Blocks[i].Forms[k].RoofType))
										{
											Interface.AddMessage(MessageType.Error, false, "RoofStructureIndex references a RoofCL not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
										}
										else
										{
											ObjectManager.CreateStaticObject((StaticObject)Data.Structure.RoofCL[Data.Blocks[i].Forms[k].RoofType], pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
										}
									}
								}
								else if (Data.Blocks[i].Forms[k].SecondaryRail == Form.SecondaryRailR)
								{
									if (!Data.Structure.FormR.ContainsKey(Data.Blocks[i].Forms[k].FormType))
									{
										Interface.AddMessage(MessageType.Error, false, "FormStructureIndex references a FormR not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
									}
									else
									{
										Data.Structure.FormR[Data.Blocks[i].Forms[k].FormType].CreateObject(pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
									}
									if (!Data.Structure.FormCR.ContainsKey(Data.Blocks[i].Forms[k].FormType))
									{
										Interface.AddMessage(MessageType.Error, false, "FormStructureIndex references a FormCR not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
									}
									else
									{
										ObjectManager.CreateStaticObject((StaticObject)Data.Structure.FormCR[Data.Blocks[i].Forms[k].FormType], pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
									}
									if (Data.Blocks[i].Forms[k].RoofType > 0)
									{
										if (!Data.Structure.RoofR.ContainsKey(Data.Blocks[i].Forms[k].RoofType))
										{
											Interface.AddMessage(MessageType.Error, false, "RoofStructureIndex references a RoofR not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
										}
										else
										{
											Data.Structure.RoofR[Data.Blocks[i].Forms[k].RoofType].CreateObject(pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
										}
										if (!Data.Structure.RoofCR.ContainsKey(Data.Blocks[i].Forms[k].RoofType))
										{
											Interface.AddMessage(MessageType.Error, false, "RoofStructureIndex references a RoofCR not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
										}
										else
										{
											ObjectManager.CreateStaticObject((StaticObject)Data.Structure.RoofCR[Data.Blocks[i].Forms[k].RoofType], pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
										}
									}
								}
								else if (Data.Blocks[i].Forms[k].SecondaryRail > 0)
								{
									int p = Data.Blocks[i].Forms[k].PrimaryRail;
									double px0 = p > 0 ? Data.Blocks[i].Rails[p].RailStart.X : 0.0;
									double px1 = p > 0 ? Data.Blocks[i + 1].Rails[p].RailEnd.X : 0.0;
									int s = Data.Blocks[i].Forms[k].SecondaryRail;
									if (s < 0 || s >= Data.Blocks[i].Rails.Length || !Data.Blocks[i].Rails[s].RailStarted)
									{
										Interface.AddMessage(MessageType.Error, false, "RailIndex2 is out of range in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName);
									}
									else
									{
										double sx0 = Data.Blocks[i].Rails[s].RailStart.X;
										double sx1 = Data.Blocks[i + 1].Rails[s].RailEnd.X;
										double d0 = sx0 - px0;
										double d1 = sx1 - px1;
										if (d0 < 0.0)
										{
											if (!Data.Structure.FormL.ContainsKey(Data.Blocks[i].Forms[k].FormType))
											{
												Interface.AddMessage(MessageType.Error, false, "FormStructureIndex references a FormL not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
											}
											else
											{
												Data.Structure.FormL[Data.Blocks[i].Forms[k].FormType].CreateObject(pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
											}
											if (!Data.Structure.FormCL.ContainsKey(Data.Blocks[i].Forms[k].FormType))
											{
												Interface.AddMessage(MessageType.Error, false, "FormStructureIndex references a FormCL not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
											}
											else
											{
												StaticObject FormC = GetTransformedStaticObject((StaticObject)Data.Structure.FormCL[Data.Blocks[i].Forms[k].FormType], d0, d1);
												ObjectManager.CreateStaticObject(FormC, pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
											}
											if (Data.Blocks[i].Forms[k].RoofType > 0)
											{
												if (!Data.Structure.RoofL.ContainsKey(Data.Blocks[i].Forms[k].RoofType))
												{
													Interface.AddMessage(MessageType.Error, false, "RoofStructureIndex references a RoofL not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
												}
												else
												{
													Data.Structure.RoofL[Data.Blocks[i].Forms[k].RoofType].CreateObject(pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
												}
												if (!Data.Structure.RoofCL.ContainsKey(Data.Blocks[i].Forms[k].RoofType))
												{
													Interface.AddMessage(MessageType.Error, false, "RoofStructureIndex references a RoofCL not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
												}
												else
												{
													StaticObject RoofC = GetTransformedStaticObject((StaticObject)Data.Structure.RoofCL[Data.Blocks[i].Forms[k].RoofType], d0, d1);
													ObjectManager.CreateStaticObject(RoofC, pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
												}
											}
										}
										else if (d0 > 0.0)
										{
											if (!Data.Structure.FormR.ContainsKey(Data.Blocks[i].Forms[k].FormType))
											{
												Interface.AddMessage(MessageType.Error, false, "FormStructureIndex references a FormR not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
											}
											else
											{
												Data.Structure.FormR[Data.Blocks[i].Forms[k].FormType].CreateObject(pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
											}
											if (!Data.Structure.FormCR.ContainsKey(Data.Blocks[i].Forms[k].FormType))
											{
												Interface.AddMessage(MessageType.Error, false, "FormStructureIndex references a FormCR not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
											}
											else
											{
												StaticObject FormC = GetTransformedStaticObject((StaticObject)Data.Structure.FormCR[Data.Blocks[i].Forms[k].FormType], d0, d1);
												ObjectManager.CreateStaticObject(FormC, pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
											}
											if (Data.Blocks[i].Forms[k].RoofType > 0)
											{
												if (!Data.Structure.RoofR.ContainsKey(Data.Blocks[i].Forms[k].RoofType))
												{
													Interface.AddMessage(MessageType.Error, false, "RoofStructureIndex references a RoofR not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
												}
												else
												{
													Data.Structure.RoofR[Data.Blocks[i].Forms[k].RoofType].CreateObject(pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
												}
												if (!Data.Structure.RoofCR.ContainsKey(Data.Blocks[i].Forms[k].RoofType))
												{
													Interface.AddMessage(MessageType.Error, false, "RoofStructureIndex references a RoofCR not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
												}
												else
												{
													StaticObject RoofC = GetTransformedStaticObject((StaticObject)Data.Structure.RoofCR[Data.Blocks[i].Forms[k].RoofType], d0, d1);
													ObjectManager.CreateStaticObject(RoofC, pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
												}
											}
										}
									}
								}
							}
							// secondary rail
							if (Data.Blocks[i].Forms[k].SecondaryRail == j)
							{
								int p = Data.Blocks[i].Forms[k].PrimaryRail;
								double px = p > 0 ? Data.Blocks[i].Rails[p].RailStart.X : 0.0;
								int s = Data.Blocks[i].Forms[k].SecondaryRail;
								double sx = Data.Blocks[i].Rails[s].RailStart.X;
								double d = px - sx;
								if (d < 0.0)
								{
									if (!Data.Structure.FormL.ContainsKey(Data.Blocks[i].Forms[k].FormType))
									{
										Interface.AddMessage(MessageType.Error, false, "FormStructureIndex references a FormL not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
									}
									else
									{
										Data.Structure.FormL[Data.Blocks[i].Forms[k].FormType].CreateObject(pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
									}
									if (Data.Blocks[i].Forms[k].RoofType > 0)
									{
										if (!Data.Structure.RoofL.ContainsKey(Data.Blocks[i].Forms[k].RoofType))
										{
											Interface.AddMessage(MessageType.Error, false, "RoofStructureIndex references a RoofL not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
										}
										else
										{
											Data.Structure.RoofL[Data.Blocks[i].Forms[k].RoofType].CreateObject(pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
										}
									}
								}
								else
								{
									if (!Data.Structure.FormR.ContainsKey(Data.Blocks[i].Forms[k].FormType))
									{
										Interface.AddMessage(MessageType.Error, false, "FormStructureIndex references a FormR not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
									}
									else
									{
										Data.Structure.FormR[Data.Blocks[i].Forms[k].FormType].CreateObject(pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
									}
									if (Data.Blocks[i].Forms[k].RoofType > 0)
									{
										if (!Data.Structure.RoofR.ContainsKey(Data.Blocks[i].Forms[k].RoofType))
										{
											Interface.AddMessage(MessageType.Error, false, "RoofStructureIndex references a RoofR not loaded in Track.Form at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
										}
										else
										{
											Data.Structure.RoofR[Data.Blocks[i].Forms[k].RoofType].CreateObject(pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
										}
									}
								}
							}
						}
						// cracks
						for (int k = 0; k < Data.Blocks[i].Cracks.Length; k++)
						{
							if (Data.Blocks[i].Cracks[k].PrimaryRail == j)
							{
								int p = Data.Blocks[i].Cracks[k].PrimaryRail;
								double px0 = p > 0 ? Data.Blocks[i].Rails[p].RailStart.X : 0.0;
								double px1 = p > 0 ? Data.Blocks[i + 1].Rails[p].RailEnd.X : 0.0;
								int s = Data.Blocks[i].Cracks[k].SecondaryRail;
								if (s < 0 || s >= Data.Blocks[i].Rails.Length || !Data.Blocks[i].Rails[s].RailStarted)
								{
									Interface.AddMessage(MessageType.Error, false, "RailIndex2 is out of range in Track.Crack at track position " + StartingDistance.ToString(Culture) + " in file " + FileName);
								}
								else
								{
									double sx0 = Data.Blocks[i].Rails[s].RailStart.X;
									double sx1 = Data.Blocks[i + 1].Rails[s].RailEnd.X;
									double d0 = sx0 - px0;
									double d1 = sx1 - px1;
									if (d0 < 0.0)
									{
										if (!Data.Structure.CrackL.ContainsKey(Data.Blocks[i].Cracks[k].Type))
										{
											Interface.AddMessage(MessageType.Error, false, "CrackStructureIndex references a CrackL not loaded in Track.Crack at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
										}
										else
										{
											StaticObject Crack = GetTransformedStaticObject((StaticObject)Data.Structure.CrackL[Data.Blocks[i].Cracks[k].Type], d0, d1);
											ObjectManager.CreateStaticObject(Crack, pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
										}
									}
									else if (d0 > 0.0)
									{
										if (!Data.Structure.CrackR.ContainsKey(Data.Blocks[i].Cracks[k].Type))
										{
											Interface.AddMessage(MessageType.Error, false, "CrackStructureIndex references a CrackR not loaded in Track.Crack at track position " + StartingDistance.ToString(Culture) + " in file " + FileName + ".");
										}
										else
										{
											StaticObject Crack = GetTransformedStaticObject((StaticObject)Data.Structure.CrackR[Data.Blocks[i].Cracks[k].Type], d0, d1);
											ObjectManager.CreateStaticObject(Crack, pos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, StartingDistance);
										}
									}
								}
							}
						}
						// free objects
						if (Data.Blocks[i].RailFreeObj.Length > j && Data.Blocks[i].RailFreeObj[j] != null)
						{
							for (int k = 0; k < Data.Blocks[i].RailFreeObj[j].Length; k++)
							{
								int sttype = Data.Blocks[i].RailFreeObj[j][k].Type;
								double dx = Data.Blocks[i].RailFreeObj[j][k].Position.X;
								double dy = Data.Blocks[i].RailFreeObj[j][k].Position.Y;
								double dz = Data.Blocks[i].RailFreeObj[j][k].TrackPosition - StartingDistance;
								Vector3 wpos = pos;
								wpos += dx * RailTransformation.X + dy * RailTransformation.Y + dz * RailTransformation.Z;
								double tpos = Data.Blocks[i].RailFreeObj[j][k].TrackPosition;
								UnifiedObject obj;
								Data.Structure.FreeObjects.TryGetValue(sttype, out obj);
								obj.CreateObject(wpos, RailTransformation, new Transformation(Data.Blocks[i].RailFreeObj[j][k].Yaw, Data.Blocks[i].RailFreeObj[j][k].Pitch, Data.Blocks[i].RailFreeObj[j][k].Roll), -1, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, tpos, 1.0, false);
							}
						}
						// transponder objects
						if (j == 0)
						{
							for (int k = 0; k < Data.Blocks[i].Transponders.Length; k++)
							{
								UnifiedObject obj = null;
								if (Data.Blocks[i].Transponders[k].ShowDefaultObject)
								{
									switch (Data.Blocks[i].Transponders[k].Type)
									{
										case 0: obj = CompatibilityObjects.TransponderS; break;
										case 1: obj = CompatibilityObjects.TransponderSN; break;
										case 2: obj = CompatibilityObjects.TransponderFalseStart; break;
										case 3: obj = CompatibilityObjects.TransponderPOrigin; break;
										case 4: obj = CompatibilityObjects.TransponderPStop; break;
									}
								}
								else
								{
									int b = Data.Blocks[i].Transponders[k].BeaconStructureIndex;
									if (b >= 0 & Data.Structure.Beacon.ContainsKey(b))
									{
										obj = Data.Structure.Beacon[b];
									}
								}
								if (obj != null)
								{
									double dx = Data.Blocks[i].Transponders[k].Position.X;
									double dy = Data.Blocks[i].Transponders[k].Position.Y;
									double dz = Data.Blocks[i].Transponders[k].TrackPosition - StartingDistance;
									Vector3 wpos = pos;
									wpos += dx * RailTransformation.X + dy * RailTransformation.Y + dz * RailTransformation.Z;
									double tpos = Data.Blocks[i].Transponders[k].TrackPosition;
									if (Data.Blocks[i].Transponders[k].ShowDefaultObject)
									{
										double b = 0.25 + 0.75 * GetBrightness(ref Data, tpos);
										obj.CreateObject(wpos, RailTransformation, new Transformation(Data.Blocks[i].Transponders[k].Yaw, Data.Blocks[i].Transponders[k].Pitch, Data.Blocks[i].Transponders[k].Roll), -1, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, tpos, b, false);
									}
									else
									{
										obj.CreateObject(wpos, RailTransformation, new Transformation(Data.Blocks[i].Transponders[k].Yaw, Data.Blocks[i].Transponders[k].Pitch, Data.Blocks[i].Transponders[k].Roll), Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, tpos);
									}
								}
							}
							for (int k = 0; k < Data.Blocks[i].DestinationChanges.Length; k++)
							{
								UnifiedObject obj = null;
								int b = Data.Blocks[i].DestinationChanges[k].BeaconStructureIndex;
								if (b >= 0 & Data.Structure.Beacon.ContainsKey(b))
								{
									obj = Data.Structure.Beacon[b];
								}
								if (obj != null)
								{
									double dx = Data.Blocks[i].DestinationChanges[k].Position.X;
									double dy = Data.Blocks[i].DestinationChanges[k].Position.Y;
									double dz = Data.Blocks[i].DestinationChanges[k].TrackPosition - StartingDistance;
									Vector3 wpos = pos;
									wpos += dx * RailTransformation.X + dy * RailTransformation.Y + dz * RailTransformation.Z;
									double tpos = Data.Blocks[i].DestinationChanges[k].TrackPosition;
									obj.CreateObject(wpos, RailTransformation, new Transformation(Data.Blocks[i].DestinationChanges[k].Yaw, Data.Blocks[i].DestinationChanges[k].Pitch, Data.Blocks[i].DestinationChanges[k].Roll), Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, tpos);
								}
							}
						}
						// sections/signals/transponders
						if (j == 0)
						{
							// signals
							for (int k = 0; k < Data.Blocks[i].Signals.Length; k++)
							{
								SignalData sd;
								if (Data.Blocks[i].Signals[k].SignalCompatibilityObjectIndex >= 0)
								{
									sd = Data.CompatibilitySignals[Data.Blocks[i].Signals[k].SignalCompatibilityObjectIndex];
								}
								else
								{
									sd = Data.Signals[Data.Blocks[i].Signals[k].SignalObjectIndex];
								}
								// objects
								double dz = Data.Blocks[i].Signals[k].TrackPosition - StartingDistance;
								if (Data.Blocks[i].Signals[k].ShowPost)
								{
									// post
									double dx = Data.Blocks[i].Signals[k].Position.X;
									Vector3 wpos = pos;
									wpos += dx * RailTransformation.X + dz * RailTransformation.Z;
									double tpos = Data.Blocks[i].Signals[k].TrackPosition;
									double b = 0.25 + 0.75 * GetBrightness(ref Data, tpos);
									ObjectManager.CreateStaticObject(CompatibilityObjects.SignalPost, wpos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, 0.0, StartingDistance, EndingDistance, Data.BlockInterval, tpos, b);
								}
								if (Data.Blocks[i].Signals[k].ShowObject)
								{
									// signal object
									double dx = Data.Blocks[i].Signals[k].Position.X;
									double dy = Data.Blocks[i].Signals[k].Position.Y;
									Vector3 wpos = pos;
									wpos += dx * RailTransformation.X + dy * RailTransformation.Y + dz * RailTransformation.Z;
									double tpos = Data.Blocks[i].Signals[k].TrackPosition;
									if (sd is AnimatedObjectSignalData)
									{
										AnimatedObjectSignalData aosd = (AnimatedObjectSignalData)sd;
										aosd.Objects.CreateObject(wpos, RailTransformation, new Transformation(Data.Blocks[i].Signals[k].Yaw, Data.Blocks[i].Signals[k].Pitch, Data.Blocks[i].Signals[k].Roll), Data.Blocks[i].Signals[k].SectionIndex, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, tpos, 1.0, false);
									}
									else if (sd is CompatibilitySignalData)
									{
										CompatibilitySignalData csd = (CompatibilitySignalData)sd;
										if (csd.Numbers.Length != 0)
										{
											double brightness = 0.25 + 0.75 * GetBrightness(ref Data, tpos);
											ObjectManager.AnimatedObjectCollection aoc = new ObjectManager.AnimatedObjectCollection();
											aoc.Objects = new ObjectManager.AnimatedObject[1];
											aoc.Objects[0] = new ObjectManager.AnimatedObject();
											aoc.Objects[0].States = new AnimatedObjectState[csd.Numbers.Length];
											for (int l = 0; l < csd.Numbers.Length; l++)
											{
												aoc.Objects[0].States[l].Object = (StaticObject)csd.Objects[l].Clone();
											}
											string expr = "";
											for (int l = 0; l < csd.Numbers.Length - 1; l++)
											{
												expr += "section " + csd.Numbers[l].ToString(Culture) + " <= " + l.ToString(Culture) + " ";
											}
											expr += (csd.Numbers.Length - 1).ToString(Culture);
											for (int l = 0; l < csd.Numbers.Length - 1; l++)
											{
												expr += " ?";
											}
											aoc.Objects[0].StateFunction = new FunctionScript(Program.CurrentHost, expr, false);
											aoc.Objects[0].RefreshRate = 1.0 + 0.01 * Program.RandomNumberGenerator.NextDouble();
											aoc.CreateObject(wpos, RailTransformation, new Transformation(Data.Blocks[i].Signals[k].Yaw, Data.Blocks[i].Signals[k].Pitch, Data.Blocks[i].Signals[k].Roll), Data.Blocks[i].Signals[k].SectionIndex, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, tpos, brightness, false);
										}
									}
									else if (sd is Bve4SignalData)
									{
										Bve4SignalData b4sd = (Bve4SignalData)sd;
										if (b4sd.SignalTextures.Length != 0)
										{
											int m = Math.Max(b4sd.SignalTextures.Length, b4sd.GlowTextures.Length);
											int zn = 0;
											for (int l = 0; l < m; l++)
											{
												if (l < b4sd.SignalTextures.Length && b4sd.SignalTextures[l] != null || l < b4sd.GlowTextures.Length && b4sd.GlowTextures[l] != null)
												{
													zn++;
												}
											}
											ObjectManager.AnimatedObjectCollection aoc = new ObjectManager.AnimatedObjectCollection();
											aoc.Objects = new ObjectManager.AnimatedObject[1];
											aoc.Objects[0] = new ObjectManager.AnimatedObject();
											aoc.Objects[0].States = new AnimatedObjectState[zn];
											int zi = 0;
											string expr = "";
											for (int l = 0; l < m; l++)
											{
												bool qs = l < b4sd.SignalTextures.Length && b4sd.SignalTextures[l] != null;
												bool qg = l < b4sd.GlowTextures.Length && b4sd.GlowTextures[l] != null;
												StaticObject so = new StaticObject(Program.CurrentHost);
												StaticObject go = null;
												if (qs & qg)
												{

													if (b4sd.BaseObject != null)
													{
														so = b4sd.BaseObject.Clone(b4sd.SignalTextures[l], null);
													}
													if (b4sd.GlowObject != null)
													{
														go = b4sd.GlowObject.Clone(b4sd.GlowTextures[l], null);
													}
													so.JoinObjects(go);
													aoc.Objects[0].States[zi].Object = so;
												}
												else if (qs)
												{
													if (b4sd.BaseObject != null)
													{
														so = b4sd.BaseObject.Clone(b4sd.SignalTextures[l], null);
													}
													aoc.Objects[0].States[zi].Object = so;
												}
												else if (qg)
												{
													if (b4sd.GlowObject != null)
													{
														go = b4sd.GlowObject.Clone(b4sd.GlowTextures[l], null);
													}
													aoc.Objects[0].States[zi].Object = go;
												}
												if (qs | qg)
												{
													if (zi < zn - 1)
													{
														expr += "section " + l.ToString(Culture) + " <= " + zi.ToString(Culture) + " ";
													}
													else
													{
														expr += zi.ToString(Culture);
													}
													zi++;
												}
											}
											for (int l = 0; l < zn - 1; l++)
											{
												expr += " ?";
											}
											aoc.Objects[0].StateFunction = new FunctionScript(Program.CurrentHost, expr, false);
											aoc.Objects[0].RefreshRate = 1.0 + 0.01 * Program.RandomNumberGenerator.NextDouble();
											aoc.CreateObject(wpos, RailTransformation, new Transformation(Data.Blocks[i].Signals[k].Yaw, Data.Blocks[i].Signals[k].Pitch, Data.Blocks[i].Signals[k].Roll), Data.Blocks[i].Signals[k].SectionIndex, Data.AccurateObjectDisposal, StartingDistance, EndingDistance, Data.BlockInterval, tpos, 1.0, false);
										}
									}
								}
							}
							// sections
							for (int k = 0; k < Data.Blocks[i].Sections.Length; k++)
							{
								int m = CurrentRoute.Sections.Length;
								Array.Resize <SignalManager.Section>(ref CurrentRoute.Sections, m + 1);
								// create associated transponders
								for (int g = 0; g <= i; g++)
								{
									for (int l = 0; l < Data.Blocks[g].Transponders.Length; l++)
									{
										if (Data.Blocks[g].Transponders[l].Type != -1 & Data.Blocks[g].Transponders[l].SectionIndex == m)
										{
											int o = TrackManager.Tracks[0].Elements[n - i + g].Events.Length;
											Array.Resize<TrackManager.GeneralEvent>(ref TrackManager.Tracks[0].Elements[n - i + g].Events, o + 1);
											double dt = Data.Blocks[g].Transponders[l].TrackPosition - StartingDistance + (double)(i - g) * Data.BlockInterval;
											TrackManager.Tracks[0].Elements[n - i + g].Events[o] = new TrackManager.TransponderEvent(dt, Data.Blocks[g].Transponders[l].Type, Data.Blocks[g].Transponders[l].Data, m, Data.Blocks[g].Transponders[l].ClipToFirstRedSection);
											Data.Blocks[g].Transponders[l].Type = -1;
										}
									}
								}
								// create section
								CurrentRoute.Sections[m].TrackPosition = Data.Blocks[i].Sections[k].TrackPosition;
								CurrentRoute.Sections[m].Aspects = new SectionAspect[Data.Blocks[i].Sections[k].Aspects.Length];
								for (int l = 0; l < Data.Blocks[i].Sections[k].Aspects.Length; l++)
								{
									CurrentRoute.Sections[m].Aspects[l].Number = Data.Blocks[i].Sections[k].Aspects[l];
									if (Data.Blocks[i].Sections[k].Aspects[l] >= 0 & Data.Blocks[i].Sections[k].Aspects[l] < Data.SignalSpeeds.Length)
									{
										CurrentRoute.Sections[m].Aspects[l].Speed = Data.SignalSpeeds[Data.Blocks[i].Sections[k].Aspects[l]];
									}
									else
									{
										CurrentRoute.Sections[m].Aspects[l].Speed = double.PositiveInfinity;
									}
								}
								CurrentRoute.Sections[m].Type = Data.Blocks[i].Sections[k].Type;
								CurrentRoute.Sections[m].CurrentAspect = -1;
								if (m > 0)
								{
									CurrentRoute.Sections[m].PreviousSection = m - 1;
									CurrentRoute.Sections[m - 1].NextSection = m;
								}
								else
								{
									CurrentRoute.Sections[m].PreviousSection = -1;
								}
								CurrentRoute.Sections[m].NextSection = -1;
								CurrentRoute.Sections[m].StationIndex = Data.Blocks[i].Sections[k].DepartureStationIndex;
								CurrentRoute.Sections[m].Invisible = Data.Blocks[i].Sections[k].Invisible;
								CurrentRoute.Sections[m].Trains = new AbstractTrain[] { };
								// create section change event
								double d = Data.Blocks[i].Sections[k].TrackPosition - StartingDistance;
								int p = TrackManager.Tracks[0].Elements[n].Events.Length;
								Array.Resize<TrackManager.GeneralEvent>(ref TrackManager.Tracks[0].Elements[n].Events, p + 1);
								TrackManager.Tracks[0].Elements[n].Events[p] = new TrackManager.SectionChangeEvent(d, m - 1, m);
							}
							// transponders introduced after corresponding sections
							for (int l = 0; l < Data.Blocks[i].Transponders.Length; l++)
							{
								if (Data.Blocks[i].Transponders[l].Type != -1)
								{
									int t = Data.Blocks[i].Transponders[l].SectionIndex;
									if (t >= 0 & t < CurrentRoute.Sections.Length)
									{
										int m = TrackManager.Tracks[0].Elements[n].Events.Length;
										Array.Resize<TrackManager.GeneralEvent>(ref TrackManager.Tracks[0].Elements[n].Events, m + 1);
										double dt = Data.Blocks[i].Transponders[l].TrackPosition - StartingDistance;
										TrackManager.Tracks[0].Elements[n].Events[m] = new TrackManager.TransponderEvent(dt, Data.Blocks[i].Transponders[l].Type, Data.Blocks[i].Transponders[l].Data, t, Data.Blocks[i].Transponders[l].ClipToFirstRedSection);
										Data.Blocks[i].Transponders[l].Type = -1;
									}
								}
							}
						}
						// limit
						if (j == 0)
						{
							for (int k = 0; k < Data.Blocks[i].Limits.Length; k++)
							{
								if (Data.Blocks[i].Limits[k].Direction != 0)
								{
									double dx = 2.2 * (double)Data.Blocks[i].Limits[k].Direction;
									double dz = Data.Blocks[i].Limits[k].TrackPosition - StartingDistance;
									Vector3 wpos = pos;
									wpos += dx * RailTransformation.X + dz * RailTransformation.Z;
									double tpos = Data.Blocks[i].Limits[k].TrackPosition;
									double b = 0.25 + 0.75 * GetBrightness(ref Data, tpos);
									if (Data.Blocks[i].Limits[k].Speed <= 0.0 | Data.Blocks[i].Limits[k].Speed >= 1000.0)
									{
										ObjectManager.CreateStaticObject(CompatibilityObjects.LimitPostInfinite, wpos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, 0.0, StartingDistance, EndingDistance, Data.BlockInterval, tpos, b);
									}
									else
									{
										if (Data.Blocks[i].Limits[k].Cource < 0)
										{
											ObjectManager.CreateStaticObject(CompatibilityObjects.LimitPostLeft, wpos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, 0.0, StartingDistance, EndingDistance, Data.BlockInterval, tpos, b);
										}
										else if (Data.Blocks[i].Limits[k].Cource > 0)
										{
											ObjectManager.CreateStaticObject(CompatibilityObjects.LimitPostRight, wpos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, 0.0, StartingDistance, EndingDistance, Data.BlockInterval, tpos, b);
										}
										else
										{
											ObjectManager.CreateStaticObject(CompatibilityObjects.LimitPostStraight, wpos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, 0.0, StartingDistance, EndingDistance, Data.BlockInterval, tpos, b);
										}
										double lim = Data.Blocks[i].Limits[k].Speed / Data.UnitOfSpeed;
										if (lim < 10.0)
										{
											int d0 = (int)Math.Round(lim);
											int o = ObjectManager.CreateStaticObject(CompatibilityObjects.LimitOneDigit, wpos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, 0.0, StartingDistance, EndingDistance, Data.BlockInterval, tpos, b);
											if (ObjectManager.Objects[o].Mesh.Materials.Length >= 1)
											{
												Program.CurrentHost.RegisterTexture(OpenBveApi.Path.CombineFile(LimitGraphicsPath, "limit_" + d0 + ".png"), new TextureParameters(null, null), out ObjectManager.Objects[o].Mesh.Materials[0].DaytimeTexture);
											}
										}
										else if (lim < 100.0)
										{
											int d1 = (int)Math.Round(lim);
											int d0 = d1 % 10;
											d1 /= 10;
											int o = ObjectManager.CreateStaticObject(CompatibilityObjects.LimitTwoDigits, wpos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, 0.0, StartingDistance, EndingDistance, Data.BlockInterval, tpos, b);
											if (ObjectManager.Objects[o].Mesh.Materials.Length >= 1)
											{
												Program.CurrentHost.RegisterTexture(OpenBveApi.Path.CombineFile(LimitGraphicsPath, "limit_" + d1 + ".png"), new TextureParameters(null, null), out ObjectManager.Objects[o].Mesh.Materials[0].DaytimeTexture);
											}
											if (ObjectManager.Objects[o].Mesh.Materials.Length >= 2)
											{
												Program.CurrentHost.RegisterTexture(OpenBveApi.Path.CombineFile(LimitGraphicsPath, "limit_" + d0 + ".png"), new TextureParameters(null, null), out ObjectManager.Objects[o].Mesh.Materials[1].DaytimeTexture);
											}
										}
										else
										{
											int d2 = (int)Math.Round(lim);
											int d0 = d2 % 10;
											int d1 = (d2 / 10) % 10;
											d2 /= 100;
											int o = ObjectManager.CreateStaticObject(CompatibilityObjects.LimitThreeDigits, wpos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, 0.0, StartingDistance, EndingDistance, Data.BlockInterval, tpos, b);
											if (ObjectManager.Objects[o].Mesh.Materials.Length >= 1)
											{
												Program.CurrentHost.RegisterTexture(OpenBveApi.Path.CombineFile(LimitGraphicsPath, "limit_" + d2 + ".png"), new TextureParameters(null, null), out ObjectManager.Objects[o].Mesh.Materials[0].DaytimeTexture);
											}
											if (ObjectManager.Objects[o].Mesh.Materials.Length >= 2)
											{
												Program.CurrentHost.RegisterTexture(OpenBveApi.Path.CombineFile(LimitGraphicsPath, "limit_" + d1 + ".png"), new TextureParameters(null, null), out ObjectManager.Objects[o].Mesh.Materials[1].DaytimeTexture);
											}
											if (ObjectManager.Objects[o].Mesh.Materials.Length >= 3)
											{
												Program.CurrentHost.RegisterTexture(OpenBveApi.Path.CombineFile(LimitGraphicsPath, "limit_" + d0 + ".png"), new TextureParameters(null, null), out ObjectManager.Objects[o].Mesh.Materials[2].DaytimeTexture);
											}
										}
									}
								}
							}
						}
						// stop
						if (j == 0)
						{
							for (int k = 0; k < Data.Blocks[i].StopPositions.Length; k++)
							{
								if (Data.Blocks[i].StopPositions[k].Direction != 0)
								{
									double dx = 1.8 * (double)Data.Blocks[i].StopPositions[k].Direction;
									double dz = Data.Blocks[i].StopPositions[k].TrackPosition - StartingDistance;
									Vector3 wpos = pos;
									wpos += dx * RailTransformation.X + dz * RailTransformation.Z;
									double tpos = Data.Blocks[i].StopPositions[k].TrackPosition;
									double b = 0.25 + 0.75 * GetBrightness(ref Data, tpos);
									ObjectManager.CreateStaticObject(CompatibilityObjects.StopPost, wpos, RailTransformation, NullTransformation, Data.AccurateObjectDisposal, 0.0, StartingDistance, EndingDistance, Data.BlockInterval, tpos, b);
								}
							}
						}
					}
				}
				// finalize block
				Position.X += Direction.X * c;
				Position.Y += h;
				Position.Z += Direction.Y * c;
				if (a != 0.0)
				{
					Direction.Rotate(Math.Cos(-a), Math.Sin(-a));
				}
			}
			// orphaned transponders
			if (!PreviewOnly)
			{
				for (int i = Data.FirstUsedBlock; i < Data.Blocks.Length; i++)
				{
					for (int j = 0; j < Data.Blocks[i].Transponders.Length; j++)
					{
						if (Data.Blocks[i].Transponders[j].Type != -1)
						{
							int n = i - Data.FirstUsedBlock;
							int m = TrackManager.Tracks[0].Elements[n].Events.Length;
							Array.Resize<TrackManager.GeneralEvent>(ref TrackManager.Tracks[0].Elements[n].Events, m + 1);
							double d = Data.Blocks[i].Transponders[j].TrackPosition - TrackManager.Tracks[0].Elements[n].StartingTrackPosition;
							int s = Data.Blocks[i].Transponders[j].SectionIndex;
							if (s >= 0) s = -1;
							TrackManager.Tracks[0].Elements[n].Events[m] = new TrackManager.TransponderEvent(d, Data.Blocks[i].Transponders[j].Type, Data.Blocks[i].Transponders[j].Data, s, Data.Blocks[i].Transponders[j].ClipToFirstRedSection);
							Data.Blocks[i].Transponders[j].Type = -1;
						}
					}
					// Destination Change Events
					for (int j = 0; j < Data.Blocks[i].DestinationChanges.Length; j++)
					{
						int n = i - Data.FirstUsedBlock;
						int m = TrackManager.Tracks[0].Elements[n].Events.Length;
						Array.Resize<TrackManager.GeneralEvent>(ref TrackManager.Tracks[0].Elements[n].Events, m + 1);
						double d = Data.Blocks[i].DestinationChanges[j].TrackPosition - TrackManager.Tracks[0].Elements[n].StartingTrackPosition;
						TrackManager.Tracks[0].Elements[n].Events[m] = new TrackManager.DestinationEvent(d, Data.Blocks[i].DestinationChanges[j].Type, Data.Blocks[i].DestinationChanges[j].NextDestination, Data.Blocks[i].DestinationChanges[j].PreviousDestination, Data.Blocks[i].DestinationChanges[j].TriggerOnce);
					}
				}
			}
			// insert station end events
			for (int i = 0; i < Game.Stations.Length; i++)
			{
				int j = Game.Stations[i].Stops.Length - 1;
				if (j >= 0)
				{
					double p = Game.Stations[i].Stops[j].TrackPosition + Game.Stations[i].Stops[j].ForwardTolerance + Data.BlockInterval;
					int k = (int)Math.Floor(p / (double)Data.BlockInterval) - Data.FirstUsedBlock;
					if (k >= 0 & k < Data.Blocks.Length)
					{
						double d = p - (double)(k + Data.FirstUsedBlock) * (double)Data.BlockInterval;
						int m = TrackManager.Tracks[0].Elements[k].Events.Length;
						Array.Resize<TrackManager.GeneralEvent>(ref TrackManager.Tracks[0].Elements[k].Events, m + 1);
						TrackManager.Tracks[0].Elements[k].Events[m] = new TrackManager.StationEndEvent(d, i);
					}
				}
			}
			// create default point of interests
			if (Game.PointsOfInterest.Length == 0)
			{
				Game.PointsOfInterest = new OpenBve.Game.PointOfInterest[Game.Stations.Length];
				int n = 0;
				for (int i = 0; i < Game.Stations.Length; i++)
				{
					if (Game.Stations[i].Stops.Length != 0)
					{
						Game.PointsOfInterest[n].Text = Game.Stations[i].Name;
						Game.PointsOfInterest[n].TrackPosition = Game.Stations[i].Stops[0].TrackPosition;
						Game.PointsOfInterest[n].TrackOffset = new Vector3(0.0, 2.8, 0.0);
						if (Game.Stations[i].OpenLeftDoors & !Game.Stations[i].OpenRightDoors)
						{
							Game.PointsOfInterest[n].TrackOffset.X = -2.5;
						}
						else if (!Game.Stations[i].OpenLeftDoors & Game.Stations[i].OpenRightDoors)
						{
							Game.PointsOfInterest[n].TrackOffset.X = 2.5;
						}
						n++;
					}
				}
				Array.Resize<Game.PointOfInterest>(ref Game.PointsOfInterest, n);
			}
			// convert block-based cant into point-based cant
			for (int i = 0; i < TrackManager.Tracks.Length; i++)
			{
				for (int j = CurrentTrackLength - 1; j >= 1; j--)
				{
					if (TrackManager.Tracks[i].Elements[j].CurveCant == 0.0)
					{
						TrackManager.Tracks[i].Elements[j].CurveCant = TrackManager.Tracks[i].Elements[j - 1].CurveCant;
					}
					else if (TrackManager.Tracks[i].Elements[j - 1].CurveCant != 0.0)
					{
						if (Math.Sign(TrackManager.Tracks[i].Elements[j - 1].CurveCant) == Math.Sign(TrackManager.Tracks[i].Elements[j].CurveCant))
						{
							if (Math.Abs(TrackManager.Tracks[i].Elements[j - 1].CurveCant) > Math.Abs(TrackManager.Tracks[i].Elements[j].CurveCant))
							{
								TrackManager.Tracks[i].Elements[j].CurveCant = TrackManager.Tracks[i].Elements[j - 1].CurveCant;
							}
						}
						else
						{
							TrackManager.Tracks[i].Elements[j].CurveCant = 0.5 * (TrackManager.Tracks[i].Elements[j].CurveCant + TrackManager.Tracks[i].Elements[j - 1].CurveCant);
						}
					}
				}
			}
			// finalize
			for (int i = 0; i < TrackManager.Tracks.Length; i++)
			{
				Array.Resize<TrackManager.TrackElement>(ref TrackManager.Tracks[i].Elements, CurrentTrackLength);
			}
			for (int i = 0; i < Game.Stations.Length; i++)
			{
				if (Game.Stations[i].Stops.Length == 0 & Game.Stations[i].StopMode != StationStopMode.AllPass)
				{
					Interface.AddMessage(MessageType.Warning, false, "Station " + Game.Stations[i].Name + " expects trains to stop but does not define stop points at track position " + Game.Stations[i].DefaultTrackPosition.ToString(Culture) + " in file " + FileName);
					Game.Stations[i].StopMode = StationStopMode.AllPass;
				}
				if (Game.Stations[i].Type == StationType.ChangeEnds)
				{
					if (i < Game.Stations.Length - 1)
					{
						if (Game.Stations[i + 1].StopMode != StationStopMode.AllStop)
						{
							Interface.AddMessage(MessageType.Warning, false, "Station " + Game.Stations[i].Name + " is marked as \"change ends\" but the subsequent station does not expect all trains to stop in file " + FileName);
							Game.Stations[i + 1].StopMode = StationStopMode.AllStop;
						}
					}
					else
					{
						Interface.AddMessage(MessageType.Warning, false, "Station " + Game.Stations[i].Name + " is marked as \"change ends\" but there is no subsequent station defined in file " + FileName);
						Game.Stations[i].Type = StationType.Terminal;
					}
				}
			}
			if (Game.Stations.Length != 0)
			{
				Game.Stations[Game.Stations.Length - 1].Type = StationType.Terminal;
			}
			if (TrackManager.Tracks[0].Elements.Length != 0)
			{
				int n = TrackManager.Tracks[0].Elements.Length - 1;
				int m = TrackManager.Tracks[0].Elements[n].Events.Length;
				Array.Resize<TrackManager.GeneralEvent>(ref TrackManager.Tracks[0].Elements[n].Events, m + 1);
				TrackManager.Tracks[0].Elements[n].Events[m] = new TrackManager.TrackEndEvent(Data.BlockInterval);
			}
			// insert compatibility beacons
			if (!PreviewOnly)
			{
				List<TrackManager.TransponderEvent> transponders = new List<TrackManager.TransponderEvent>();
				bool atc = false;
				for (int i = 0; i < TrackManager.Tracks[0].Elements.Length; i++)
				{
					for (int j = 0; j < TrackManager.Tracks[0].Elements[i].Events.Length; j++)
					{
						if (!atc)
						{
							if (TrackManager.Tracks[0].Elements[i].Events[j] is TrackManager.StationStartEvent)
							{
								TrackManager.StationStartEvent station = (TrackManager.StationStartEvent)TrackManager.Tracks[0].Elements[i].Events[j];
								if (Game.Stations[station.StationIndex].SafetySystem == SafetySystem.Atc)
								{
									Array.Resize<TrackManager.GeneralEvent>(ref TrackManager.Tracks[0].Elements[i].Events, TrackManager.Tracks[0].Elements[i].Events.Length + 2);
									TrackManager.Tracks[0].Elements[i].Events[TrackManager.Tracks[0].Elements[i].Events.Length - 2] = new TrackManager.TransponderEvent(0.0, TrackManager.SpecialTransponderTypes.AtcTrackStatus, 0, 0, false);
									TrackManager.Tracks[0].Elements[i].Events[TrackManager.Tracks[0].Elements[i].Events.Length - 1] = new TrackManager.TransponderEvent(0.0, TrackManager.SpecialTransponderTypes.AtcTrackStatus, 1, 0, false);
									atc = true;
								}
							}
						}
						else
						{
							if (TrackManager.Tracks[0].Elements[i].Events[j] is TrackManager.StationStartEvent)
							{
								TrackManager.StationStartEvent station = (TrackManager.StationStartEvent)TrackManager.Tracks[0].Elements[i].Events[j];
								if (Game.Stations[station.StationIndex].SafetySystem == SafetySystem.Ats)
								{
									Array.Resize<TrackManager.GeneralEvent>(ref TrackManager.Tracks[0].Elements[i].Events, TrackManager.Tracks[0].Elements[i].Events.Length + 2);
									TrackManager.Tracks[0].Elements[i].Events[TrackManager.Tracks[0].Elements[i].Events.Length - 2] = new TrackManager.TransponderEvent(0.0, TrackManager.SpecialTransponderTypes.AtcTrackStatus, 2, 0, false);
									TrackManager.Tracks[0].Elements[i].Events[TrackManager.Tracks[0].Elements[i].Events.Length - 1] = new TrackManager.TransponderEvent(0.0, TrackManager.SpecialTransponderTypes.AtcTrackStatus, 3, 0, false);
								}
							}
							else if (TrackManager.Tracks[0].Elements[i].Events[j] is TrackManager.StationEndEvent)
							{
								TrackManager.StationEndEvent station = (TrackManager.StationEndEvent)TrackManager.Tracks[0].Elements[i].Events[j];
								if (Game.Stations[station.StationIndex].SafetySystem == SafetySystem.Atc)
								{
									Array.Resize<TrackManager.GeneralEvent>(ref TrackManager.Tracks[0].Elements[i].Events, TrackManager.Tracks[0].Elements[i].Events.Length + 2);
									TrackManager.Tracks[0].Elements[i].Events[TrackManager.Tracks[0].Elements[i].Events.Length - 2] = new TrackManager.TransponderEvent(0.0, TrackManager.SpecialTransponderTypes.AtcTrackStatus, 1, 0, false);
									TrackManager.Tracks[0].Elements[i].Events[TrackManager.Tracks[0].Elements[i].Events.Length - 1] = new TrackManager.TransponderEvent(0.0, TrackManager.SpecialTransponderTypes.AtcTrackStatus, 2, 0, false);
								}
								else if (Game.Stations[station.StationIndex].SafetySystem == SafetySystem.Ats)
								{
									Array.Resize<TrackManager.GeneralEvent>(ref TrackManager.Tracks[0].Elements[i].Events, TrackManager.Tracks[0].Elements[i].Events.Length + 2);
									TrackManager.Tracks[0].Elements[i].Events[TrackManager.Tracks[0].Elements[i].Events.Length - 2] = new TrackManager.TransponderEvent(0.0, TrackManager.SpecialTransponderTypes.AtcTrackStatus, 3, 0, false);
									TrackManager.Tracks[0].Elements[i].Events[TrackManager.Tracks[0].Elements[i].Events.Length - 1] = new TrackManager.TransponderEvent(0.0, TrackManager.SpecialTransponderTypes.AtcTrackStatus, 0, 0, false);
									atc = false;
								}
							}
							else if (TrackManager.Tracks[0].Elements[i].Events[j] is TrackManager.LimitChangeEvent)
							{
								TrackManager.LimitChangeEvent limit = (TrackManager.LimitChangeEvent)TrackManager.Tracks[0].Elements[i].Events[j];
								int speed = (int)Math.Round(Math.Min(4095.0, 3.6 * limit.NextSpeedLimit));
								int distance = Math.Min(1048575, (int)Math.Round(TrackManager.Tracks[0].Elements[i].StartingTrackPosition + limit.TrackPositionDelta));
								unchecked
								{
									int value = (int)((uint)speed | ((uint)distance << 12));
									transponders.Add(new TrackManager.TransponderEvent(0.0, TrackManager.SpecialTransponderTypes.AtcSpeedLimit, value, 0, false));
								}
							}
						}
						if (TrackManager.Tracks[0].Elements[i].Events[j] is TrackManager.TransponderEvent)
						{
							TrackManager.TransponderEvent transponder = TrackManager.Tracks[0].Elements[i].Events[j] as TrackManager.TransponderEvent;
							if (transponder.Type == TrackManager.SpecialTransponderTypes.InternalAtsPTemporarySpeedLimit)
							{
								int speed = Math.Min(4095, transponder.Data);
								int distance = Math.Min(1048575, (int)Math.Round(TrackManager.Tracks[0].Elements[i].StartingTrackPosition + transponder.TrackPositionDelta));
								unchecked
								{
									int value = (int)((uint)speed | ((uint)distance << 12));
									transponders.Add(new TrackManager.TransponderEvent(0.0, TrackManager.SpecialTransponderTypes.AtsPTemporarySpeedLimit, value, 0, false));
								}
							}
						}
					}
				}
				int n = TrackManager.Tracks[0].Elements[0].Events.Length;
				Array.Resize<TrackManager.GeneralEvent>(ref TrackManager.Tracks[0].Elements[0].Events, n + transponders.Count);
				for (int i = 0; i < transponders.Count; i++)
				{
					TrackManager.Tracks[0].Elements[0].Events[n + i] = transponders[i];
				}
			}
			// cant
			if (!PreviewOnly)
			{
				ComputeCantTangents();
				int subdivisions = (int)Math.Floor(Data.BlockInterval / 5.0);
				if (subdivisions >= 2)
				{
					SmoothenOutTurns(subdivisions);
					ComputeCantTangents();
				}
			}
		}

		// ------------------

		// compute cant tangents
		private static void ComputeCantTangents()
		{
			for (int i = 0; i < TrackManager.Tracks.Length; i++)
			{
				if (TrackManager.Tracks[i].Elements.Length == 1)
				{
					TrackManager.Tracks[i].Elements[0].CurveCantTangent = 0.0;
				}
				else if (TrackManager.Tracks[i].Elements.Length != 0)
				{
					double[] deltas = new double[TrackManager.Tracks[i].Elements.Length - 1];
					for (int j = 0; j < TrackManager.Tracks[i].Elements.Length - 1; j++)
					{
						deltas[j] = TrackManager.Tracks[i].Elements[j + 1].CurveCant - TrackManager.Tracks[i].Elements[j].CurveCant;
					}
					double[] tangents = new double[TrackManager.Tracks[i].Elements.Length];
					tangents[0] = deltas[0];
					tangents[TrackManager.Tracks[i].Elements.Length - 1] = deltas[TrackManager.Tracks[i].Elements.Length - 2];
					for (int j = 1; j < TrackManager.Tracks[i].Elements.Length - 1; j++)
					{
						tangents[j] = 0.5 * (deltas[j - 1] + deltas[j]);
					}
					for (int j = 0; j < TrackManager.Tracks[i].Elements.Length - 1; j++)
					{
						if (deltas[j] == 0.0)
						{
							tangents[j] = 0.0;
							tangents[j + 1] = 0.0;
						}
						else
						{
							double a = tangents[j] / deltas[j];
							double b = tangents[j + 1] / deltas[j];
							if (a * a + b * b > 9.0)
							{
								double t = 3.0 / Math.Sqrt(a * a + b * b);
								tangents[j] = t * a * deltas[j];
								tangents[j + 1] = t * b * deltas[j];
							}
						}
					}
					for (int j = 0; j < TrackManager.Tracks[i].Elements.Length; j++)
					{
						TrackManager.Tracks[i].Elements[j].CurveCantTangent = tangents[j];
					}
				}
			}
		}

		// ------------------


		// smoothen out turns
		private static void SmoothenOutTurns(int subdivisions)
		{
			if (subdivisions < 2)
			{
				throw new InvalidOperationException();
			}
			// subdivide track
			int length = TrackManager.Tracks[0].Elements.Length;
			int newLength = (length - 1) * subdivisions + 1;
			double[] midpointsTrackPositions = new double[newLength];
			Vector3[] midpointsWorldPositions = new Vector3[newLength];
			Vector3[] midpointsWorldDirections = new Vector3[newLength];
			Vector3[] midpointsWorldUps = new Vector3[newLength];
			Vector3[] midpointsWorldSides = new Vector3[newLength];
			double[] midpointsCant = new double[newLength];
			for (int i = 0; i < newLength; i++)
			{
				int m = i % subdivisions;
				if (m != 0)
				{
					int q = i / subdivisions;
					TrackManager.TrackFollower follower = new TrackManager.TrackFollower();
					double r = (double)m / (double)subdivisions;
					double p = (1.0 - r) * TrackManager.Tracks[0].Elements[q].StartingTrackPosition + r * TrackManager.Tracks[0].Elements[q + 1].StartingTrackPosition;
					follower.Update(-1.0, true, false);
					follower.Update(p, true, false);
					midpointsTrackPositions[i] = p;
					midpointsWorldPositions[i] = follower.WorldPosition;
					midpointsWorldDirections[i] = follower.WorldDirection;
					midpointsWorldUps[i] = follower.WorldUp;
					midpointsWorldSides[i] = follower.WorldSide;
					midpointsCant[i] = follower.CurveCant;
				}
			}
			Array.Resize<TrackManager.TrackElement>(ref TrackManager.Tracks[0].Elements, newLength);
			for (int i = length - 1; i >= 1; i--)
			{
				TrackManager.Tracks[0].Elements[subdivisions * i] = TrackManager.Tracks[0].Elements[i];
			}
			for (int i = 0; i < TrackManager.Tracks[0].Elements.Length; i++)
			{
				int m = i % subdivisions;
				if (m != 0)
				{
					int q = i / subdivisions;
					int j = q * subdivisions;
					TrackManager.Tracks[0].Elements[i] = TrackManager.Tracks[0].Elements[j];
					TrackManager.Tracks[0].Elements[i].Events = new TrackManager.GeneralEvent[] { };
					TrackManager.Tracks[0].Elements[i].StartingTrackPosition = midpointsTrackPositions[i];
					TrackManager.Tracks[0].Elements[i].WorldPosition = midpointsWorldPositions[i];
					TrackManager.Tracks[0].Elements[i].WorldDirection = midpointsWorldDirections[i];
					TrackManager.Tracks[0].Elements[i].WorldUp = midpointsWorldUps[i];
					TrackManager.Tracks[0].Elements[i].WorldSide = midpointsWorldSides[i];
					TrackManager.Tracks[0].Elements[i].CurveCant = midpointsCant[i];
					TrackManager.Tracks[0].Elements[i].CurveCantTangent = 0.0;
				}
			}
			// find turns
			bool[] isTurn = new bool[TrackManager.Tracks[0].Elements.Length];
			{
				TrackManager.TrackFollower follower = new TrackManager.TrackFollower();
				for (int i = 1; i < TrackManager.Tracks[0].Elements.Length - 1; i++)
				{
					int m = i % subdivisions;
					if (m == 0)
					{
						double p = 0.00000001 * TrackManager.Tracks[0].Elements[i - 1].StartingTrackPosition + 0.99999999 * TrackManager.Tracks[0].Elements[i].StartingTrackPosition;
						follower.Update(p, true, false);
						Vector3 d1 = TrackManager.Tracks[0].Elements[i].WorldDirection;
						Vector3 d2 = follower.WorldDirection;
						Vector3 d = d1 - d2;
						double t = d.X * d.X + d.Z * d.Z;
						const double e = 0.0001;
						if (t > e)
						{
							isTurn[i] = true;
						}
					}
				}
			}
			// replace turns by curves
			double totalShortage = 0.0;
			for (int i = 0; i < TrackManager.Tracks[0].Elements.Length; i++)
			{
				if (isTurn[i])
				{
					// estimate radius
					Vector3 AP = TrackManager.Tracks[0].Elements[i - 1].WorldPosition;
					Vector3 BP = TrackManager.Tracks[0].Elements[i + 1].WorldPosition;
					Vector3 S = TrackManager.Tracks[0].Elements[i - 1].WorldSide - TrackManager.Tracks[0].Elements[i + 1].WorldSide;
					double rx;
					if (S.X * S.X > 0.000001)
					{
						rx = (BP.X - AP.X) / S.X;
					}
					else
					{
						rx = 0.0;
					}
					double rz;
					if (S.Z * S.Z > 0.000001)
					{
						rz = (BP.Z - AP.Z) / S.Z;
					}
					else
					{
						rz = 0.0;
					}
					if (rx != 0.0 | rz != 0.0)
					{
						double r;
						if (rx != 0.0 & rz != 0.0)
						{
							if (Math.Sign(rx) == Math.Sign(rz))
							{
								double f = rx / rz;
								if (f > -1.1 & f < -0.9 | f > 0.9 & f < 1.1)
								{
									r = Math.Sqrt(Math.Abs(rx * rz)) * Math.Sign(rx);
								}
								else
								{
									r = 0.0;
								}
							}
							else
							{
								r = 0.0;
							}
						}
						else if (rx != 0.0)
						{
							r = rx;
						}
						else
						{
							r = rz;
						}
						if (r * r > 1.0)
						{
							// apply radius
							TrackManager.TrackFollower follower = new TrackManager.TrackFollower();
							TrackManager.Tracks[0].Elements[i - 1].CurveRadius = r;
							double p = 0.00000001 * TrackManager.Tracks[0].Elements[i - 1].StartingTrackPosition + 0.99999999 * TrackManager.Tracks[0].Elements[i].StartingTrackPosition;
							follower.Update(p - 1.0, true, false);
							follower.Update(p, true, false);
							TrackManager.Tracks[0].Elements[i].CurveRadius = r;
							TrackManager.Tracks[0].Elements[i].WorldPosition = follower.WorldPosition;
							TrackManager.Tracks[0].Elements[i].WorldDirection = follower.WorldDirection;
							TrackManager.Tracks[0].Elements[i].WorldUp = follower.WorldUp;
							TrackManager.Tracks[0].Elements[i].WorldSide = follower.WorldSide;
							// iterate to shorten track element length
							p = 0.00000001 * TrackManager.Tracks[0].Elements[i].StartingTrackPosition + 0.99999999 * TrackManager.Tracks[0].Elements[i + 1].StartingTrackPosition;
							follower.Update(p - 1.0, true, false);
							follower.Update(p, true, false);
							Vector3 d = TrackManager.Tracks[0].Elements[i + 1].WorldPosition - follower.WorldPosition;
							double bestT = d.NormSquared();
							int bestJ = 0;
							int n = 1000;
							double a = 1.0 / (double)n * (TrackManager.Tracks[0].Elements[i + 1].StartingTrackPosition - TrackManager.Tracks[0].Elements[i].StartingTrackPosition);
							for (int j = 1; j < n - 1; j++)
							{
								follower.Update(TrackManager.Tracks[0].Elements[i + 1].StartingTrackPosition - (double)j * a, true, false);
								d = TrackManager.Tracks[0].Elements[i + 1].WorldPosition - follower.WorldPosition;
								double t = d.NormSquared();
								if (t < bestT)
								{
									bestT = t;
									bestJ = j;
								}
								else
								{
									break;
								}
							}
							double s = (double)bestJ * a;
							for (int j = i + 1; j < TrackManager.Tracks[0].Elements.Length; j++)
							{
								TrackManager.Tracks[0].Elements[j].StartingTrackPosition -= s;
							}
							totalShortage += s;
							// introduce turn to compensate for curve
							p = 0.00000001 * TrackManager.Tracks[0].Elements[i].StartingTrackPosition + 0.99999999 * TrackManager.Tracks[0].Elements[i + 1].StartingTrackPosition;
							follower.Update(p - 1.0, true, false);
							follower.Update(p, true, false);
							Vector3 AB = TrackManager.Tracks[0].Elements[i + 1].WorldPosition - follower.WorldPosition;
							Vector3 AC = TrackManager.Tracks[0].Elements[i + 1].WorldPosition - TrackManager.Tracks[0].Elements[i].WorldPosition;
							Vector3 BC = follower.WorldPosition - TrackManager.Tracks[0].Elements[i].WorldPosition;
							double sa = Math.Sqrt(BC.X * BC.X + BC.Z * BC.Z);
							double sb = Math.Sqrt(AC.X * AC.X + AC.Z * AC.Z);
							double sc = Math.Sqrt(AB.X * AB.X + AB.Z * AB.Z);
							double denominator = 2.0 * sa * sb;
							if (denominator != 0.0)
							{
								double originalAngle;
								{
									double value = (sa * sa + sb * sb - sc * sc) / denominator;
									if (value < -1.0)
									{
										originalAngle = Math.PI;
									}
									else if (value > 1.0)
									{
										originalAngle = 0;
									}
									else
									{
										originalAngle = Math.Acos(value);
									}
								}
								TrackManager.TrackElement originalTrackElement = TrackManager.Tracks[0].Elements[i];
								bestT = double.MaxValue;
								bestJ = 0;
								for (int j = -1; j <= 1; j++)
								{
									double g = (double)j * originalAngle;
									double cosg = Math.Cos(g);
									double sing = Math.Sin(g);
									TrackManager.Tracks[0].Elements[i] = originalTrackElement;
									TrackManager.Tracks[0].Elements[i].WorldDirection.Rotate(Vector3.Down, cosg, sing);
									TrackManager.Tracks[0].Elements[i].WorldUp.Rotate(Vector3.Down, cosg, sing);
									TrackManager.Tracks[0].Elements[i].WorldSide.Rotate(Vector3.Down, cosg, sing);
									p = 0.00000001 * TrackManager.Tracks[0].Elements[i].StartingTrackPosition + 0.99999999 * TrackManager.Tracks[0].Elements[i + 1].StartingTrackPosition;
									follower.Update(p - 1.0, true, false);
									follower.Update(p, true, false);
									d = TrackManager.Tracks[0].Elements[i + 1].WorldPosition - follower.WorldPosition;
									double t = d.NormSquared();
									if (t < bestT)
									{
										bestT = t;
										bestJ = j;
									}
								}
								{
									double newAngle = (double)bestJ * originalAngle;
									double cosg = Math.Cos(newAngle);
									double sing = Math.Sin(newAngle);
									TrackManager.Tracks[0].Elements[i] = originalTrackElement;
									TrackManager.Tracks[0].Elements[i].WorldDirection.Rotate(Vector3.Down, cosg, sing);
									TrackManager.Tracks[0].Elements[i].WorldUp.Rotate(Vector3.Down, cosg, sing);
									TrackManager.Tracks[0].Elements[i].WorldSide.Rotate(Vector3.Down, cosg, sing);
								}
								// iterate again to further shorten track element length
								p = 0.00000001 * TrackManager.Tracks[0].Elements[i].StartingTrackPosition + 0.99999999 * TrackManager.Tracks[0].Elements[i + 1].StartingTrackPosition;
								follower.Update(p - 1.0, true, false);
								follower.Update(p, true, false);
								d = TrackManager.Tracks[0].Elements[i + 1].WorldPosition - follower.WorldPosition;
								bestT = d.NormSquared();
								bestJ = 0;
								n = 1000;
								a = 1.0 / (double)n * (TrackManager.Tracks[0].Elements[i + 1].StartingTrackPosition - TrackManager.Tracks[0].Elements[i].StartingTrackPosition);
								for (int j = 1; j < n - 1; j++)
								{
									follower.Update(TrackManager.Tracks[0].Elements[i + 1].StartingTrackPosition - (double)j * a, true, false);
									d = TrackManager.Tracks[0].Elements[i + 1].WorldPosition - follower.WorldPosition;
									double t = d.NormSquared();
									if (t < bestT)
									{
										bestT = t;
										bestJ = j;
									}
									else
									{
										break;
									}
								}
								s = (double)bestJ * a;
								for (int j = i + 1; j < TrackManager.Tracks[0].Elements.Length; j++)
								{
									TrackManager.Tracks[0].Elements[j].StartingTrackPosition -= s;
								}
								totalShortage += s;
							}
							// compensate for height difference
							p = 0.00000001 * TrackManager.Tracks[0].Elements[i].StartingTrackPosition + 0.99999999 * TrackManager.Tracks[0].Elements[i + 1].StartingTrackPosition;
							follower.Update(p - 1.0, true, false);
							follower.Update(p, true, false);
							Vector3 d1 = TrackManager.Tracks[0].Elements[i + 1].WorldPosition - TrackManager.Tracks[0].Elements[i].WorldPosition;
							double a1 = Math.Atan(d1.Y / Math.Sqrt(d1.X * d1.X + d1.Z * d1.Z));
							Vector3 d2 = follower.WorldPosition - TrackManager.Tracks[0].Elements[i].WorldPosition;
							double a2 = Math.Atan(d2.Y / Math.Sqrt(d2.X * d2.X + d2.Z * d2.Z));
							double b = a2 - a1;
							if (b * b > 0.00000001)
							{
								double cosa = Math.Cos(b);
								double sina = Math.Sin(b);
								TrackManager.Tracks[0].Elements[i].WorldDirection.Rotate(TrackManager.Tracks[0].Elements[i].WorldSide, cosa, sina);
								TrackManager.Tracks[0].Elements[i].WorldUp.Rotate(TrackManager.Tracks[0].Elements[i].WorldSide, cosa, sina);
							}
						}
					}
				}
			}
			// correct events
			for (int i = 0; i < TrackManager.Tracks[0].Elements.Length - 1; i++)
			{
				double startingTrackPosition = TrackManager.Tracks[0].Elements[i].StartingTrackPosition;
				double endingTrackPosition = TrackManager.Tracks[0].Elements[i + 1].StartingTrackPosition;
				for (int j = 0; j < TrackManager.Tracks[0].Elements[i].Events.Length; j++)
				{
					double p = startingTrackPosition + TrackManager.Tracks[0].Elements[i].Events[j].TrackPositionDelta;
					if (p >= endingTrackPosition)
					{
						int len = TrackManager.Tracks[0].Elements[i + 1].Events.Length;
						Array.Resize<TrackManager.GeneralEvent>(ref TrackManager.Tracks[0].Elements[i + 1].Events, len + 1);
						TrackManager.Tracks[0].Elements[i + 1].Events[len] = TrackManager.Tracks[0].Elements[i].Events[j];
						TrackManager.Tracks[0].Elements[i + 1].Events[len].TrackPositionDelta += startingTrackPosition - endingTrackPosition;
						for (int k = j; k < TrackManager.Tracks[0].Elements[i].Events.Length - 1; k++)
						{
							TrackManager.Tracks[0].Elements[i].Events[k] = TrackManager.Tracks[0].Elements[i].Events[k + 1];
						}
						len = TrackManager.Tracks[0].Elements[i].Events.Length;
						Array.Resize<TrackManager.GeneralEvent>(ref TrackManager.Tracks[0].Elements[i].Events, len - 1);
						j--;
					}
				}
			}
		}
	}
}
