using System;
using TrainManager.BrakeSystems;
using TrainManager.Handles;

namespace TrainManager.Trains
{
	public partial class TrainBase
	{
		/// <summary>Updates the brake system for the entire train</summary>
		/// <param name="timeElapsed">The frame time elapsed</param>
		/// <param name="decelerationDueToBrake">An array containing the deceleration figures generated by the brake system of each car in the train</param>
		/// <param name="decelerationDueToMotor">An array containing the deceleration figures generated by the motor of each car in the train (If it is a motor car)</param>
		public void UpdateBrakeSystem(double timeElapsed, out double[] decelerationDueToBrake, out double[] decelerationDueToMotor)
		{
			// individual brake systems
			decelerationDueToBrake = new double[Cars.Length];
			decelerationDueToMotor = new double[Cars.Length];
			for (int i = 0; i < Cars.Length; i++)
			{
				UpdateBrakeSystem(i, timeElapsed, out decelerationDueToBrake[i], out decelerationDueToMotor[i]);
			}

			if (Specs.AveragesPressureDistribution)
			{
				// brake pipe pressure distribution dummy (just averages)
				double totalPressure = 0.0;
				for (int i = 0; i < Cars.Length; i++)
				{
					if (i > 0)
					{
						if (Cars[i - 1].Derailed | Cars[i].Derailed)
						{
							Cars[i].CarBrake.BrakePipe.CurrentPressure -= Cars[i].CarBrake.BrakePipe.LeakRate * timeElapsed;
							if (Cars[i].CarBrake.BrakePipe.CurrentPressure < 0.0) Cars[i].CarBrake.BrakePipe.CurrentPressure = 0.0;
						}
					}

					if (i < Cars.Length - 1)
					{
						if (Cars[i].Derailed | Cars[i + 1].Derailed)
						{
							Cars[i].CarBrake.BrakePipe.CurrentPressure -= Cars[i].CarBrake.BrakePipe.LeakRate * timeElapsed;
							if (Cars[i].CarBrake.BrakePipe.CurrentPressure < 0.0) Cars[i].CarBrake.BrakePipe.CurrentPressure = 0.0;
						}
					}

					totalPressure += Cars[i].CarBrake.BrakePipe.CurrentPressure;
				}

				double averagePressure = totalPressure / Cars.Length;
				for (int i = 0; i < Cars.Length; i++)
				{
					Cars[i].CarBrake.BrakePipe.CurrentPressure = averagePressure;
				}
			}
			else
			{
				double[] tempFlowRates = new double[Cars.Length];
				for (int i = 0; i < Cars.Length; i++)
				{
					if (i > 0)
					{
						// find pressure differential between the two brake pipes
						// the sign of the number will determine the direction of flow
						double pressureDifferential = Cars[i].CarBrake.BrakePipe.CurrentPressure - Cars[i - 1].CarBrake.BrakePipe.CurrentPressure;
						// two cars, hence pressure equalizes between the two
						double totalFlow = pressureDifferential / 2.0;
						tempFlowRates[i] -= totalFlow;
						tempFlowRates[i - 1] += totalFlow;
					}
				}

				for (int i = 0; i < Cars.Length; i++)
				{
					Cars[i].CarBrake.BrakePipe.CurrentPressure += tempFlowRates[i];
					Cars[i].CarBrake.BrakePipe.CurrentPressure = Math.Max(Cars[i].CarBrake.BrakePipe.CurrentPressure, 0);
				}
			}
		}

		/// <summary>Updates the brake system for a car within this train</summary>
		/// <remarks>This must remain a property of the train, for easy access to various base properties</remarks>
		/// <param name="carIndex">The individual car</param>
		/// <param name="timeElapsed">The frame time elapsed</param>
		/// <param name="decelerationDueToBrake">The total brake deceleration this car provides</param>
		/// <param name="decelerationDueToMotor">The total motor deceleration this car provides</param>
		public void UpdateBrakeSystem(int carIndex, double timeElapsed, out double decelerationDueToBrake, out double decelerationDueToMotor)
		{
			decelerationDueToBrake = 0.0;
			decelerationDueToMotor = 0.0;
			// air compressor
			if (Cars[carIndex].CarBrake.BrakeType == BrakeType.Main)
			{
				if (Cars[carIndex].CarBrake is AirBrake airBrake)
				{
					airBrake.Compressor.Update(timeElapsed);
				}
			}

			if (carIndex == DriverCar && Handles.HasLocoBrake)
			{
				switch (Handles.LocoBrakeType)
				{
					case LocoBrakeType.Independant:
						//With an independant Loco brake, we always want to use this handle
						Cars[carIndex].CarBrake.Update(timeElapsed, Cars[DriverCar].CurrentSpeed, Handles.LocoBrake, out decelerationDueToBrake);
						break;
					case LocoBrakeType.Combined:
						if (Handles.LocoBrake is LocoBrakeHandle && Handles.Brake is NotchedHandle)
						{
							//Both handles are of the notched type
							if (Handles.Brake.MaximumNotch == Handles.LocoBrake.MaximumNotch)
							{
								//Identical number of notches, so return the handle with the higher setting
								if (Handles.LocoBrake.Actual >= Handles.Brake.Actual)
								{
									Cars[carIndex].CarBrake.Update(timeElapsed, Cars[DriverCar].CurrentSpeed, Handles.LocoBrake, out decelerationDueToBrake);
								}
								else
								{
									Cars[carIndex].CarBrake.Update(timeElapsed, Cars[DriverCar].CurrentSpeed, Handles.Brake, out decelerationDueToBrake);
								}
							}
							else if (Handles.Brake.MaximumNotch > Handles.LocoBrake.MaximumNotch)
							{
								double nc = ((double) Handles.LocoBrake.Actual / Handles.LocoBrake.MaximumNotch) * Handles.Brake.MaximumNotch;
								if (nc > Handles.Brake.Actual)
								{
									Cars[carIndex].CarBrake.Update(timeElapsed, Cars[DriverCar].CurrentSpeed, Handles.LocoBrake, out decelerationDueToBrake);
								}
								else
								{
									Cars[carIndex].CarBrake.Update(timeElapsed, Cars[DriverCar].CurrentSpeed, Handles.Brake, out decelerationDueToBrake);
								}
							}
							else
							{
								double nc = ((double) Handles.Brake.Actual / Handles.Brake.MaximumNotch) * Handles.LocoBrake.MaximumNotch;
								if (nc > Handles.LocoBrake.Actual)
								{
									Cars[carIndex].CarBrake.Update(timeElapsed, Cars[DriverCar].CurrentSpeed, Handles.Brake, out decelerationDueToBrake);
								}
								else
								{
									Cars[carIndex].CarBrake.Update(timeElapsed, Cars[DriverCar].CurrentSpeed, Handles.LocoBrake, out decelerationDueToBrake);
								}
							}
						}
						else if (Handles.LocoBrake is LocoAirBrakeHandle && Handles.Brake is AirBrakeHandle)
						{
							if (Handles.LocoBrake.Actual < Handles.Brake.Actual)
							{
								Cars[carIndex].CarBrake.Update(timeElapsed, Cars[DriverCar].CurrentSpeed, Handles.Brake, out decelerationDueToBrake);
							}
							else
							{
								Cars[carIndex].CarBrake.Update(timeElapsed, Cars[DriverCar].CurrentSpeed, Handles.LocoBrake, out decelerationDueToBrake);
							}
						}
						else
						{
							double p, tp;
							//Calculate the pressure differentials for the two handles
							if (Handles.LocoBrake is LocoAirBrakeHandle)
							{
								//Air brake handle
								p = Cars[carIndex].CarBrake.BrakeCylinder.CurrentPressure / Cars[carIndex].CarBrake.BrakeCylinder.ServiceMaximumPressure;
								tp = (Cars[carIndex].CarBrake.BrakeCylinder.ServiceMaximumPressure / Handles.Brake.MaximumNotch) * Handles.Brake.Actual;
							}
							else
							{
								//Notched handle
								p = Cars[carIndex].CarBrake.BrakeCylinder.CurrentPressure / Cars[carIndex].CarBrake.BrakeCylinder.ServiceMaximumPressure;
								tp = (Cars[carIndex].CarBrake.BrakeCylinder.ServiceMaximumPressure / Handles.LocoBrake.MaximumNotch) * Handles.LocoBrake.Actual;
							}

							if (p < tp)
							{
								Cars[carIndex].CarBrake.Update(timeElapsed, Cars[DriverCar].CurrentSpeed, Handles.Brake, out decelerationDueToBrake);
							}
							else
							{
								Cars[carIndex].CarBrake.Update(timeElapsed, Cars[DriverCar].CurrentSpeed, Handles.LocoBrake, out decelerationDueToBrake);
							}
						}

						break;
					case LocoBrakeType.Blocking:
						if (Handles.LocoBrake.Actual != 0)
						{
							Cars[carIndex].CarBrake.Update(timeElapsed, Cars[DriverCar].CurrentSpeed, Handles.LocoBrake, out decelerationDueToBrake);
						}
						else
						{
							Cars[carIndex].CarBrake.Update(timeElapsed, Cars[DriverCar].CurrentSpeed, Handles.Brake, out decelerationDueToBrake);
						}

						break;
				}

			}
			else
			{
				Cars[carIndex].CarBrake.Update(timeElapsed, Cars[DriverCar].CurrentSpeed, Handles.Brake, out decelerationDueToBrake);
			}

			Cars[carIndex].CarBrake.airSound?.Play(Cars[carIndex], false);

			// deceleration provided by motor
			if (!(Cars[carIndex].CarBrake is AutomaticAirBrake) && Math.Abs(Cars[carIndex].CurrentSpeed) >= Cars[carIndex].CarBrake.BrakeControlSpeed & Handles.Reverser.Actual != 0 & !Handles.EmergencyBrake.Actual)
			{
				if (Handles.LocoBrake.Actual != 0 && carIndex == DriverCar)
				{
					decelerationDueToMotor = Cars[carIndex].CarBrake.CurrentMotorDeceleration(timeElapsed, Handles.LocoBrake);
				}
				else
				{
					decelerationDueToMotor = Cars[carIndex].CarBrake.CurrentMotorDeceleration(timeElapsed, Handles.Brake);
				}
			}

			// hold brake
			Cars[carIndex].HoldBrake.Update(ref decelerationDueToMotor, Handles.HoldBrake.Actual);
			if(Cars[carIndex].CarBrake.BrakeType != BrakeType.None)
			{
				// brake shoe rub sound
				double spd = Math.Abs(Cars[carIndex].CurrentSpeed);
				double pitch = 1.0 / (spd + 1.0) + 1.0;
				double gain = Cars[carIndex].Derailed ? 0.0 : Cars[carIndex].CarBrake.BrakeCylinder.CurrentPressure / Cars[carIndex].CarBrake.BrakeCylinder.ServiceMaximumPressure;
				if (spd < 1.38888888888889)
				{
					double t = spd * spd;
					gain *= 1.5552 * t - 0.746496 * spd * t;
				}
				else if (spd > 12.5)
				{
					double t = spd - 12.5;
					const double fadefactor = 0.1;
					gain *= 1.0 / (fadefactor * t * t + 1.0);
				}

				if (Cars[carIndex].CarBrake.Rub.IsPlaying)
				{
					if (pitch > 0.01 & gain > 0.001)
					{
						Cars[carIndex].CarBrake.Rub.Source.Pitch = pitch;
						Cars[carIndex].CarBrake.Rub.Source.Volume = gain;
					}
					else
					{
						Cars[carIndex].CarBrake.Rub.Stop();
					}
				}
				else if (pitch > 0.02 & gain > 0.01)
				{
					Cars[carIndex].CarBrake.Rub.Play(pitch, gain, Cars[carIndex], true);
				}
			}
		}
	}
}
