using System;
using System.Collections.Generic;
using System.Linq;
using OpenBveApi.Colors;
using OpenBveApi.Math;
using OpenBveApi.Runtime;
using OpenBveApi.World;
using OpenBveApi.Interface;
using OpenBveApi.Objects;
using OpenBveApi.Textures;
using OpenBveApi.Routes;
using OpenBveApi.Sounds;
using RouteManager2.Climate;
using RouteManager2.Events;
using RouteManager2.SignalManager;
using RouteManager2.Tracks;
using OpenBveApi.Hosts;
using OpenBveApi.Trains;

namespace CsvRwRouteParser
{
	internal partial class Parser
	{
		private void ApplyRouteData(string FileName, ref RouteData Data, bool PreviewOnly)
		{
			if (CompatibilityObjectsUsed != 0)
			{
				Plugin.CurrentHost.AddMessage(MessageType.Warning, false, "Warning: " + CompatibilityObjectsUsed + " compatibility objects were used.");
			}

			if (Data.FirstUsedBlock == -1)
			{
				//Not a routefile after all then....
				throw new Exception(Translations.GetInterfaceString(HostApplication.OpenBve, new[] {"errors","route_corrupt_noobjects"}));
			}

			if (PreviewOnly)
			{
				if (freeObjCount == 0 && railtypeCount == 0)
				{
					if (missingObjectCount == 0)
					{
						throw new Exception(Translations.GetInterfaceString(HostApplication.OpenBve, new[] {"errors","route_corrupt_missingobjects"}));
					}
					throw new Exception(Translations.GetInterfaceString(HostApplication.OpenBve, new[] {"errors","route_corrupt_noobjects"}));
				}
			}
			else
			{
				CompatibilityObjects.LoadAutoGeneratedObjects(CompatibilityFolder);
			}

			if ((Data.TurnUsed && Data.SwitchUsed))
			{
				throw new Exception(Translations.GetInterfaceString(HostApplication.OpenBve, new[] { "errors", "route_switch_turn" }));
			}

			// initialize
			int LastBlock = (int)Math.Floor((Data.TrackPosition + 600.0) / Data.BlockInterval + 0.001) + 1;
			if (Math.Abs(Data.Blocks[Data.Blocks.Count - 1].CurrentTrackState.CurveRadius) < 300)
			{
				/*
				 * The track end event is placed 600m after the end of the final block
				 * If our curve radius in the final block is < 300, then our train will
				 * re-appear erroneously if the player is watching the final block
				 */
				Data.Blocks[Data.Blocks.Count - 1].CurrentTrackState.CurveRadius = 0.0;
			}

			CurrentRoute.BlockLength = Data.BlockInterval;
			CurrentRoute.AccurateObjectDisposal = Plugin.CurrentOptions.ObjectDisposalMode;
			Data.CreateMissingBlocks(LastBlock, PreviewOnly);
			// interpolate height
			if (!PreviewOnly)
			{
				int z = 0;
				for (int i = 0; i < Data.Blocks.Count; i++)
				{
					if (!double.IsNaN(Data.Blocks[i].Height))
					{
						for (int j = i - 1; j >= 0; j--)
						{
							if (!double.IsNaN(Data.Blocks[j].Height))
							{
								double a = Data.Blocks[j].Height;
								double b = Data.Blocks[i].Height;
								double d = (b - a) / (i - j);
								for (int k = j + 1; k < i; k++)
								{
									a += d;
									Data.Blocks[k].Height = a;
								}
								break;
							}
						}
						z = i;
					}
				}
				for (int i = z + 1; i < Data.Blocks.Count; i++)
				{
					Data.Blocks[i].Height = Data.Blocks[z].Height;
				}
			}
			// background
			if (!PreviewOnly)
			{
				if (Data.Backgrounds.ContainsKey(Data.Blocks[0].Background))
				{
					CurrentRoute.CurrentBackground = Data.Backgrounds[Data.Blocks[0].Background];
				}
				else
				{
					if (Plugin.CurrentOptions.EnableBveTsHacks && Data.Backgrounds.Count == 0)
					{
						/*
						 * If no backgrounds are defined, this causes some interesting render artifacts
						 */
						Plugin.CurrentHost.AddMessage(MessageType.Warning, false, "No backgrounds were defined- Using default background.");
						string f = OpenBveApi.Path.CombineFile(Plugin.FileSystem.GetDataFolder("Compatibility"), "Uchibo\\Back_Mt.png");
						Plugin.CurrentHost.RegisterTexture(f, TextureParameters.NoChange, out var t);
						CurrentRoute.CurrentBackground = new StaticBackground(t, 6, false, Plugin.CurrentOptions.ViewingDistance);
					}
					else if (Data.Backgrounds.Count > 0 && !Data.Backgrounds.ContainsKey(0) && Data.Blocks[0].Background == 0)
					{
						/*
						 * Nasty little variant on the above-
						 * Zero background is not defined, and the route doesn't start at zero
						 *
						 * Don't hide behind the hacks option, as routes can start at a non-zero position with a
						 * non-zero background quite validly
						 */
						CurrentRoute.CurrentBackground = Data.Backgrounds[Data.Backgrounds.ElementAt(0).Key];
					}
					else
					{
						CurrentRoute.CurrentBackground = new StaticBackground(null, 6, false, Plugin.CurrentOptions.ViewingDistance);
					}
				}
				CurrentRoute.TargetBackground = CurrentRoute.CurrentBackground;
			}
			// brightness
			int CurrentBrightnessElement = -1;
			int CurrentBrightnessEvent = -1;
			float CurrentBrightnessValue = 1.0f;
			double CurrentBrightnessTrackPosition = Data.FirstUsedBlock * Data.BlockInterval;
			if (!PreviewOnly)
			{
				for (int i = Data.FirstUsedBlock; i < Data.Blocks.Count; i++)
				{
					if (Data.Blocks[i].BrightnessChanges != null && Data.Blocks[i].BrightnessChanges.Length != 0)
					{
						CurrentBrightnessValue = Data.Blocks[i].BrightnessChanges[0].Value;
						CurrentBrightnessTrackPosition = Data.Blocks[i].BrightnessChanges[0].Value;
						break;
					}
				}
			}
			// create objects and track
			CurrentRoute.Switches = new Dictionary<Guid, RouteManager2.Tracks.Switch>();
			Vector3 Position = Vector3.Zero;
			Vector2 Direction = Vector2.Down;
			double CurrentSpeedLimit = double.PositiveInfinity;
			int CurrentRunIndex = 0;
			int CurrentFlangeIndex = 0;
			if (Data.FirstUsedBlock < 0) Data.FirstUsedBlock = 0;
			int CurrentTrackLength = 0;
			int PreviousFogElement = -1;
			int PreviousFogEvent = -1;
			int lastRainIntensity = 0;
			Fog PreviousFog = new Fog(CurrentRoute.NoFogStart, CurrentRoute.NoFogEnd, Color24.Grey, -Data.BlockInterval);
			Fog CurrentFog = new Fog(CurrentRoute.NoFogStart, CurrentRoute.NoFogEnd, Color24.Grey, 0.0);
			for (int i = Data.FirstUsedBlock; i < Data.Blocks.Count; i++)
			{
				for (int d = 0; d < Data.Blocks[i].Rails.Count; d++)
				{
					var item = Data.Blocks[i].Rails.ElementAt(d);
					if (!CurrentRoute.Tracks.ContainsKey(item.Key))
					{
						CurrentRoute.Tracks.Add(item.Key, new Track());
					}
				}
			}
			// process blocks
			double progressFactor = Data.Blocks.Count - Data.FirstUsedBlock == 0 ? 0.5 : 0.5 / (Data.Blocks.Count - Data.FirstUsedBlock);
			for (int i = Data.FirstUsedBlock; i < Data.Blocks.Count; i++)
			{
				Plugin.CurrentProgress = 0.6667 + (i - Data.FirstUsedBlock) * progressFactor;
				if ((i & 15) == 0)
				{
					System.Threading.Thread.Sleep(1);
					if (Plugin.Cancel)
					{
						Plugin.IsLoading = false;
						return;
					}
				}
				double StartingDistance = i * Data.BlockInterval;
				double EndingDistance = StartingDistance + Data.BlockInterval;
				// normalize
				Direction.Normalize();
				// track
				if (!PreviewOnly)
				{
					if (Data.Blocks[i].Cycle.Length == 1 && Data.Blocks[i].Cycle[0] == -1)
					{
						if (Data.Structure.Cycles.Length == 0 || Data.Structure.Cycles[0] == null)
						{
							Data.Blocks[i].Cycle = new[] { 0 };
						}
						else
						{
							Data.Blocks[i].Cycle = Data.Structure.Cycles[0];
						}
					}
				}
				TrackElement WorldTrackElement = Data.Blocks[i].CurrentTrackState;
				int n = CurrentTrackLength;
				for (int j = 0; j < CurrentRoute.Tracks.Count; j++)
				{
					var key = CurrentRoute.Tracks.ElementAt(j).Key;
					if (n >= CurrentRoute.Tracks[key].Elements.Length)
					{
						Array.Resize(ref CurrentRoute.Tracks[key].Elements, CurrentRoute.Tracks[key].Elements.Length << 1);
					}
				}
				CurrentTrackLength++;
				CurrentRoute.Tracks[0].Elements[n] = WorldTrackElement;
				CurrentRoute.Tracks[0].Elements[n].WorldPosition = Position;
				CurrentRoute.Tracks[0].Elements[n].WorldDirection = Vector3.GetVector3(Direction, Data.Blocks[i].Pitch);
				CurrentRoute.Tracks[0].Elements[n].WorldSide = new Vector3(Direction.Y, 0.0, -Direction.X);
				CurrentRoute.Tracks[0].Elements[n].WorldUp = Vector3.Cross(CurrentRoute.Tracks[0].Elements[n].WorldDirection, CurrentRoute.Tracks[0].Elements[n].WorldSide);
				CurrentRoute.Tracks[0].Elements[n].StartingTrackPosition = StartingDistance;
				CurrentRoute.Tracks[0].Elements[n].AdhesionMultiplier = Data.Blocks[i].Rails[0].AdhesionMultiplier;
				CurrentRoute.Tracks[0].Elements[n].RainIntensity = Data.Blocks[i].RainIntensity;
				CurrentRoute.Tracks[0].Elements[n].SnowIntensity = Data.Blocks[i].SnowIntensity;
				CurrentRoute.Tracks[0].Elements[n].IsDriveable = true; // Current CSV / RW route limitation: Rail 0 is always the player path
				if (Data.Blocks[i].RainIntensity != lastRainIntensity)
				{
					//Insert compatibility beacon for OS_ATS et. al
					CurrentRoute.Tracks[0].Elements[n].Events.Add(new TransponderEvent(Plugin.CurrentRoute, 0.0, 21, Data.Blocks[i].RainIntensity, -1, false));
					lastRainIntensity = Data.Blocks[i].RainIntensity;
				}
				CurrentRoute.Tracks[0].Elements[n].CsvRwAccuracyLevel = Data.Blocks[i].Rails[0].Accuracy;
				for (int j = 0; j < CurrentRoute.Tracks.Count; j++)
				{
					if (PreviewOnly && j != 0)
					{
						break;
					}
					var key = CurrentRoute.Tracks.ElementAt(j).Key;
					CurrentRoute.Tracks[key].Elements[n].Events = new List<GeneralEvent>();
				}
				// background
				if (!PreviewOnly)
				{
					if (Data.Blocks[i].Background >= 0)
					{
						int typ;
						if (i == Data.FirstUsedBlock)
						{
							typ = Data.Blocks[i].Background;
						}
						else
						{
							typ = Data.Backgrounds.Count > 0 ? 0 : -1;
							for (int j = i - 1; j >= Data.FirstUsedBlock; j--)
							{
								if (Data.Blocks[j].Background >= 0)
								{
									typ = Data.Blocks[j].Background;
									break;
								}
							}
						}

						if (!Data.Backgrounds.ContainsKey(typ) && Data.Backgrounds.ContainsKey(Data.Blocks[0].Background))
						{
							/*
							 * Rare case where Background zero is not defined & the first .Back command is at
							 * position zero
							 */
							typ = Data.Blocks[0].Background;
						}
						if (Data.Backgrounds.TryGetValue(typ, out var background))
						{
							CurrentRoute.Tracks[0].Elements[n].Events.Add(new BackgroundChangeEvent(CurrentRoute, 0.0, background, Data.Backgrounds[Data.Blocks[i].Background]));
						}
					}
				}
				// brightness
				if (!PreviewOnly)
				{
					for (int j = 0; j < Data.Blocks[i].BrightnessChanges.Length; j++)
					{
						Data.Blocks[i].BrightnessChanges[j].Create(CurrentRoute, StartingDistance, n, ref CurrentBrightnessElement, ref CurrentBrightnessEvent, ref CurrentBrightnessTrackPosition, ref CurrentBrightnessValue);
					}
				}
				// fog
				if (!PreviewOnly)
				{
					if (Data.FogTransitionMode)
					{
						if (Data.Blocks[i].FogDefined)
						{
							if (i == 0 && StartingDistance == 0)
							{
								//Fog starts at zero position
								PreviousFog = Data.Blocks[i].Fog;
							}
							Data.Blocks[i].Fog.TrackPosition = StartingDistance;
							CurrentRoute.Tracks[0].Elements[n].Events.Add(new FogChangeEvent(CurrentRoute, 0.0, PreviousFog, Data.Blocks[i].Fog, Data.Blocks[i].Fog));
							if (PreviousFogElement >= 0 && PreviousFogEvent >= 0)
							{
								FogChangeEvent e = (FogChangeEvent)CurrentRoute.Tracks[0].Elements[PreviousFogElement].Events[PreviousFogEvent];
								e.NextFog = Data.Blocks[i].Fog;
							}
							else
							{
								CurrentRoute.PreviousFog = PreviousFog;
								CurrentRoute.CurrentFog = PreviousFog;
								CurrentRoute.NextFog = Data.Blocks[i].Fog;
							}
							PreviousFog = Data.Blocks[i].Fog;
							PreviousFogElement = n;
							PreviousFogEvent = CurrentRoute.Tracks[0].Elements[n].Events.Count - 1;
						}
					}
					else
					{
						if (i == 0 && StartingDistance == 0)
						{
							//Fog starts at zero position
							CurrentFog = Data.Blocks[i].Fog;
							PreviousFog = CurrentFog;
							CurrentRoute.PreviousFog = CurrentFog;
							CurrentRoute.CurrentFog = CurrentFog;
							CurrentRoute.NextFog = CurrentFog;


						}
						else
						{
							Data.Blocks[i].Fog.TrackPosition = StartingDistance + Data.BlockInterval;
							CurrentRoute.Tracks[0].Elements[n].Events.Add(new FogChangeEvent(CurrentRoute, 0.0, PreviousFog, CurrentFog, Data.Blocks[i].Fog));
							PreviousFog = CurrentFog;
							CurrentFog = Data.Blocks[i].Fog;
						}
					}
				}
				// rail sounds
				if (!PreviewOnly)
				{
					int j = Data.Blocks[i].RailType[0];
					int r = j < Data.Structure.Run.Length ? Data.Structure.Run[j] : 0;
					int f = j < Data.Structure.Flange.Length ? Data.Structure.Flange[j] : 0;
					if (CurrentRunIndex != r || CurrentFlangeIndex != f)
					{
						CurrentRoute.Tracks[0].Elements[n].Events.Add(new RailSoundsChangeEvent(0.0, CurrentRunIndex, CurrentFlangeIndex, r, f));
					}
					
					CurrentRunIndex = r;
					CurrentFlangeIndex = f;
				}
				// point sound
				if (!PreviewOnly)
				{
					if (i < Data.Blocks.Count - 1)
					{
						for (int jj = 0; jj < Data.Blocks[i].Rails.Count; jj++)
						{
							int j = Data.Blocks[i].Rails.ElementAt(jj).Key;
							if (Data.Blocks[i].Rails[j].RailStarted && Data.Blocks[i + 1].Rails.ContainsKey(j))
							{
								bool q = false;
								for (int kk = 0; kk < Data.Blocks[i].Rails.Count; kk++)
								{
									int k = Data.Blocks[i].Rails.ElementAt(kk).Key;
									if (Data.Blocks[i].Rails[k].RailStarted && Data.Blocks[i + 1].Rails.ContainsKey(k))
									{
										bool qx = Math.Sign(Data.Blocks[i].Rails[k].RailStart.X - Data.Blocks[i].Rails[j].RailStart.X) != Math.Sign(Data.Blocks[i + 1].Rails[k].RailEnd.X - Data.Blocks[i + 1].Rails[j].RailEnd.X);
										bool qy = (Data.Blocks[i].Rails[k].RailStart.Y - Data.Blocks[i].Rails[j].RailStart.Y) * (Data.Blocks[i + 1].Rails[k].RailEnd.Y - Data.Blocks[i + 1].Rails[j].RailEnd.Y) <= 0.0;
										if (qx && qy)
										{
											q = true;
											break;
										}
									}
								}
								if (q)
								{
									bool addPointSound = true;
									if (Data.Blocks[i].Switches != null)
									{
										for (int sw = 0; sw < Data.Blocks[i].Switches.Length; sw++)
										{
											if (Data.Blocks[i].Switches[sw] != null)
											{
												if (sw == j || Data.Blocks[i].Switches[sw].SecondTrack == j)
												{
													/*
													 * Switches are obviously(?) going to be on intersecting tracks
													 * This means that we don't want to add the default point sound when Rail0 intersects with
													 * another, but should do it in the switch instead for consistancy
													 * 
													 * Longer term, the original point sound method should really be got rid of entirely
													 * (Parser option??)
													 */
													addPointSound = false;
													break;
												}
												
											}
										}
									}
									if (addPointSound)
									{
										CurrentRoute.Tracks[j].Elements[n].Events.Add(new PointSoundEvent());
									}
									
								}
							}
						}
					}
				}
				// power supplies
				if (!PreviewOnly)
				{
					for (int jj = 0; jj < Data.Blocks[i].Rails.Count; jj++)
					{
						int j = Data.Blocks[i].Rails.ElementAt(jj).Key;
						CurrentRoute.Tracks[j].Elements[n].PowerSupplies = Data.Blocks[i].Rails[j].PowerSupplies;
					}
				}
				// station
				if (Data.Blocks[i].Station >= 0)
				{
					// station
					int s = Data.Blocks[i].Station;
					if (CurrentRoute.Tracks[0].Direction == TrackDirection.Reverse)
					{
						CurrentRoute.Tracks[0].Elements[n].Events.Add(new StationEndEvent(Plugin.CurrentHost, Plugin.CurrentRoute, 0.0, s));
					}
					else
					{
							CurrentRoute.Tracks[0].Elements[n].Events.Add(new StationStartEvent(CurrentRoute, 0.0, s));
					}
					
					double dx, dy = 3.0;
					if (CurrentRoute.Stations[s].OpenLeftDoors && !CurrentRoute.Stations[s].OpenRightDoors)
					{
						dx = -5.0;
					}
					else if (!CurrentRoute.Stations[s].OpenLeftDoors && CurrentRoute.Stations[s].OpenRightDoors)
					{
						dx = 5.0;
					}
					else
					{
						dx = 0.0;
					}
					CurrentRoute.Stations[s].SoundOrigin = Position + dx * CurrentRoute.Tracks[0].Elements[n].WorldSide + dy * CurrentRoute.Tracks[0].Elements[n].WorldUp;
					// passalarm
					if (!PreviewOnly)
					{
						if (Data.Blocks[i].StationPassAlarm)
						{
							int b = Data.BlockInterval != 25.0 ? i - (int) (150.0 / Data.BlockInterval) : i - 6;
							if (b >= 0)
							{
								int j = b - Data.FirstUsedBlock;
								if (j >= 0)
								{
									CurrentRoute.Tracks[0].Elements[j].Events.Add(new StationPassAlarmEvent(0.0));
								}
							}
						}
					}
				}
				// stop
				for (int j = 0; j < Data.Blocks[i].StopPositions.Length; j++)
				{
					Data.Blocks[i].StopPositions[j].CreateEvent(ref CurrentRoute.Stations, Position, CurrentRoute.Tracks[0].Elements[n].WorldUp, CurrentRoute.Tracks[0].Elements[n].WorldSide);
				}
				// limit
				if (!PreviewOnly)
				{
					for (int j = 0; j < Data.Blocks[i].Limits.Length; j++)
					{
						Data.Blocks[i].Limits[j].CreateEvent(StartingDistance, ref CurrentSpeedLimit, ref CurrentRoute.Tracks[Data.Blocks[i].Limits[j].RailIndex].Elements[n]);
					}
				}
				// marker
				if (!PreviewOnly)
				{
					for (int j = 0; j < Data.Markers.Count; j++)
					{
						Data.Markers[j].CreateEvent(StartingDistance, EndingDistance, ref CurrentRoute.Tracks[0].Elements[n]);
					}
				}
				// request stops
				if (!PreviewOnly)
				{
					for (int j = 0; j < Data.RequestStops.Count; j++)
					{
						Data.RequestStops[j].CreateEvent(StartingDistance, EndingDistance, ref CurrentRoute.Tracks[0].Elements[n]);
						
					}
				}
				// sound
				if (!PreviewOnly)
				{
					for (int j = 0; j < Data.Blocks[i].SoundEvents.Length; j++)
					{
						if ((int)Data.Blocks[i].SoundEvents[j].Type > 1 && (int)Data.Blocks[i].SoundEvents[j].Type < 6 )
						{
							double d = Data.Blocks[i].SoundEvents[j].TrackPosition - StartingDistance;
							int railIndex = Data.Blocks[i].SoundEvents[j].RailIndex;
							switch (Data.Blocks[i].SoundEvents[j].Type)
							{
								case SoundType.TrainStatic:
									CurrentRoute.Tracks[railIndex].Elements[n].Events.Add(new SoundEvent(Plugin.CurrentHost, d, Data.Blocks[i].SoundEvents[j].SoundBuffer, true, true, false, Vector3.Zero));
									break;
								case SoundType.TrainAllCarStatic:
									CurrentRoute.Tracks[railIndex].Elements[n].Events.Add(new SoundEvent(Plugin.CurrentHost, d, Data.Blocks[i].SoundEvents[j].SoundBuffer, true, true, true, false, Vector3.Zero));
									break;
								case SoundType.TrainDynamic:
									CurrentRoute.Tracks[railIndex].Elements[n].Events.Add(new SoundEvent(Plugin.CurrentHost, d, Data.Blocks[i].SoundEvents[j].SoundBuffer, false, false, false, true, Vector3.Zero, Data.Blocks[i].SoundEvents[j].Speed));
									break;
								case SoundType.TrainAllCarDynamic:
									CurrentRoute.Tracks[railIndex].Elements[n].Events.Add(new SoundEvent(Plugin.CurrentHost, d, Data.Blocks[i].SoundEvents[j].SoundBuffer, false, true, false, true, Vector3.Zero, Data.Blocks[i].SoundEvents[j].Speed));
									break;
							}
						}
					}
				}
				// turn
				if (Data.Blocks[i].Turn != 0.0)
				{
					double ag = -Math.Atan(Data.Blocks[i].Turn);
					double cosag = Math.Cos(ag);
					double sinag = Math.Sin(ag);
					Direction.Rotate(cosag, sinag);
					CurrentRoute.Tracks[0].Elements[n].WorldDirection.RotatePlane(cosag, sinag);
					CurrentRoute.Tracks[0].Elements[n].WorldSide.RotatePlane(cosag, sinag);
					CurrentRoute.Tracks[0].Elements[n].WorldUp = Vector3.Cross(CurrentRoute.Tracks[0].Elements[n].WorldDirection, CurrentRoute.Tracks[0].Elements[n].WorldSide);
				}
				//Pitch
				CurrentRoute.Tracks[0].Elements[n].Pitch = Data.Blocks[i].Pitch;
				// curves
				double a = 0.0;
				double c = Data.BlockInterval;
				double h = 0.0;
				if (WorldTrackElement.CurveRadius != 0.0 && Data.Blocks[i].Pitch != 0.0)
				{
					double d = Data.BlockInterval;
					double p = Data.Blocks[i].Pitch;
					double r = WorldTrackElement.CurveRadius;
					double s = d / Math.Sqrt(1.0 + p * p);
					h = s * p;
					double b = s / Math.Abs(r);
					c = Math.Sqrt(2.0 * r * r * (1.0 - Math.Cos(b)));
					a = 0.5 * Math.Sign(r) * b;
					Direction.Rotate(Math.Cos(-a), Math.Sin(-a));
				}
				else if (WorldTrackElement.CurveRadius != 0.0)
				{
					double d = Data.BlockInterval;
					double r = WorldTrackElement.CurveRadius;
					double b = d / Math.Abs(r);
					c = Math.Sqrt(2.0 * r * r * (1.0 - Math.Cos(b)));
					a = 0.5 * Math.Sign(r) * b;
					Direction.Rotate(Math.Cos(-a), Math.Sin(-a));
				}
				else if (Data.Blocks[i].Pitch != 0.0)
				{
					double p = Data.Blocks[i].Pitch;
					double d = Data.BlockInterval;
					c = d / Math.Sqrt(1.0 + p * p);
					h = c * p;
				}

				double TrackYaw = Math.Atan2(Direction.X, Direction.Y);
				double TrackPitch = Math.Atan(Data.Blocks[i].Pitch);
				Transformation GroundTransformation = new Transformation(TrackYaw, 0.0, 0.0);
				Transformation TrackTransformation = new Transformation(TrackYaw, TrackPitch, 0.0);
				
				// switches
				if (!PreviewOnly)
				{
					for (int j = 0; j < Data.Blocks[i].Switches.Length; j++)
					{
						if (Data.Blocks[i].Switches[j] != null)
						{

							Guid newSwitch = Guid.NewGuid();
							if (Data.Blocks[i].Switches[j].Trailing == false)
							{
								SwitchType type = SwitchType.LeftHanded;
								if (Data.Blocks[i + 1].Rails[j].RailStart.X < Data.Blocks[i + 1].Rails[Data.Blocks[i].Switches[j].SecondTrack].RailStart.X)
								{
									type = SwitchType.RightHanded;
								}
								CurrentRoute.Switches.Add(newSwitch, new RouteManager2.Tracks.Switch(new[] { j, Data.Blocks[i].Switches[j].SecondTrack }, Data.Blocks[i].Switches[j].TrackNames, j, Data.Blocks[i].Switches[j].InitialSetting, CurrentRoute.Tracks[0].Elements[n].StartingTrackPosition, type,  Data.Blocks[i].Switches[j].Name, Data.Blocks[i].Switches[j].FixedRoute, TrackDirection.Forwards));
								//Assign facing switch event
								CurrentRoute.Tracks[j].Elements[n].Events.Add(new SwitchEvent(newSwitch, CurrentRoute));
								CurrentRoute.Tracks[j].Elements[n].Events.Add(new PointSoundEvent());
								//Assign trailing switch event
								CurrentRoute.Tracks[Data.Blocks[i].Switches[j].SecondTrack].Elements[n].Events.Add(new SwitchEvent(newSwitch,  CurrentRoute));
								CurrentRoute.Tracks[j].Elements[n].ContainsSwitch = true;
							}
							else
							{
								SwitchType type = SwitchType.LeftHanded;
								if (Data.Blocks[i - 1].Rails[j].RailStart.X > Data.Blocks[i - 1].Rails[Data.Blocks[i].Switches[j].SecondTrack].RailStart.X)
								{
									type = SwitchType.RightHanded;
								}
								CurrentRoute.Switches.Add(newSwitch, new RouteManager2.Tracks.Switch(new[] { Data.Blocks[i].Switches[j].SecondTrack, j }, Data.Blocks[i].Switches[j].TrackNames, j, Data.Blocks[i].Switches[j].InitialSetting, CurrentRoute.Tracks[0].Elements[n].StartingTrackPosition, type,  Data.Blocks[i].Switches[j].Name, Data.Blocks[i].Switches[j].FixedRoute, TrackDirection.Reverse));
								//Assign facing switch event
								CurrentRoute.Tracks[j].Elements[n].Events.Add(new SwitchEvent(newSwitch, CurrentRoute));
								CurrentRoute.Tracks[j].Elements[n].Events.Add(new PointSoundEvent());
								//Assign trailing switch event
								CurrentRoute.Tracks[Data.Blocks[i].Switches[j].SecondTrack].Elements[n].Events.Add(new SwitchEvent(newSwitch, CurrentRoute));
								CurrentRoute.Tracks[j].Elements[n].ContainsSwitch = true;
								
							}
						}
					}
				}

				// ground
				if (!PreviewOnly)
				{
					int cb = (int)Math.Floor(i + 0.001);
					int ci = (cb % Data.Blocks[i].Cycle.Length + Data.Blocks[i].Cycle.Length) % Data.Blocks[i].Cycle.Length;
					int gi = Data.Blocks[i].Cycle[ci];
					if (Data.Structure.Ground.ContainsKey(gi))
					{
						Data.Structure.Ground[Data.Blocks[i].Cycle[ci]].CreateObject(Position + new Vector3(0.0, -Data.Blocks[i].Height, 0.0), GroundTransformation, StartingDistance, EndingDistance, StartingDistance);
					}
				}
				// ground-aligned free objects
				if (!PreviewOnly)
				{
					for (int j = 0; j < Data.Blocks[i].GroundFreeObj.Count; j++)
					{
						Data.Blocks[i].GroundFreeObj[j].CreateGroundAligned(Data.Structure.FreeObjects, Position, GroundTransformation, Direction, Data.Blocks[i].Height, StartingDistance, EndingDistance);
					}
				}
				if (!PreviewOnly && Data.Structure.WeatherObjects.ContainsKey(Data.Blocks[i].WeatherObject))
				{
					UnifiedObject obj = Data.Structure.WeatherObjects[Data.Blocks[i].WeatherObject];
					obj.CreateObject(Position, GroundTransformation, Data.Blocks[i].Height, StartingDistance, EndingDistance);
				}
				// rail-aligned objects
				{
					for (int railInBlock = 0; railInBlock < Data.Blocks[i].Rails.Count; railInBlock++)
					{
						int railKey = Data.Blocks[i].Rails.ElementAt(railInBlock).Key;
						if (railKey > 0 && !Data.Blocks[i].Rails[railKey].RailStarted && !Plugin.CurrentRoute.Tracks[railKey].Elements[n].ContainsSwitch)
						{
							// NOTE: If element contains a switch, it must be valid
							Plugin.CurrentRoute.Tracks[railKey].Elements[n].InvalidElement = true;

						}
						// rail
						Vector3 pos;
						Transformation RailTransformation = new Transformation();
						double planar, updown;
						if (railKey == 0)
						{
							// rail 0
							planar = 0.0;
							updown = 0.0;
							RailTransformation = new Transformation(TrackTransformation, planar, updown, 0.0);
							pos = Position;
						}
						else
						{
							// rails 1-infinity
							double x = Data.Blocks[i].Rails[railKey].RailStart.X;
							double y = Data.Blocks[i].Rails[railKey].RailStart.Y;
							Vector3 offset = new Vector3(Direction.Y * x, y, -Direction.X * x);
							pos = Position + offset;
							if (i < Data.Blocks.Count - 1 && Data.Blocks[i + 1].Rails.ContainsKey(railKey))
							{
								// take orientation of upcoming block into account
								Vector2 Direction2 = Direction;
								Vector3 Position2 = Position;
								Position2.X += Direction.X * c;
								Position2.Y += h;
								Position2.Z += Direction.Y * c;
								if (a != 0.0)
								{
									Direction2.Rotate(Math.Cos(-a), Math.Sin(-a));
								}
								if (Data.Blocks[i + 1].Turn != 0.0)
								{
									double ag = -Math.Atan(Data.Blocks[i + 1].Turn);
									double cosag = Math.Cos(ag);
									double sinag = Math.Sin(ag);
									Direction2.Rotate(cosag, sinag);
								}
								double a2;
								// double c2 = Data.BlockInterval;
								// double h2 = 0.0;
								if (Data.Blocks[i + 1].CurrentTrackState.CurveRadius != 0.0 && Data.Blocks[i + 1].Pitch != 0.0)
								{
									double d2 = Data.BlockInterval;
									double p2 = Data.Blocks[i + 1].Pitch;
									double r2 = Data.Blocks[i + 1].CurrentTrackState.CurveRadius;
									double s2 = d2 / Math.Sqrt(1.0 + p2 * p2);
									// h2 = s2 * p2;
									double b2 = s2 / Math.Abs(r2);
									// c2 = Math.Sqrt(2.0 * r2 * r2 * (1.0 - Math.Cos(b2)));
									a2 = 0.5 * Math.Sign(r2) * b2;
									Direction2.Rotate(Math.Cos(-a2), Math.Sin(-a2));
								}
								else if (Data.Blocks[i + 1].CurrentTrackState.CurveRadius != 0.0)
								{
									double d2 = Data.BlockInterval;
									double r2 = Data.Blocks[i + 1].CurrentTrackState.CurveRadius;
									double b2 = d2 / Math.Abs(r2);
									// c2 = Math.Sqrt(2.0 * r2 * r2 * (1.0 - Math.Cos(b2)));
									a2 = 0.5 * Math.Sign(r2) * b2;
									Direction2.Rotate(Math.Cos(-a2), Math.Sin(-a2));
								}
								// else if (Data.Blocks[i + 1].Pitch != 0.0) {
								// double p2 = Data.Blocks[i + 1].Pitch;
								// double d2 = Data.BlockInterval;
								// c2 = d2 / Math.Sqrt(1.0 + p2 * p2);
								// h2 = c2 * p2;
								// }

								//These generate a compiler warning, as secondary tracks do not generate yaw, as they have no
								//concept of a curve, but rather are a straight line between two points
								//TODO: Revist the handling of secondary tracks ==> !!BACKWARDS INCOMPATIBLE!!
								/*
								double TrackYaw2 = Math.Atan2(Direction2.X, Direction2.Y);
								double TrackPitch2 = Math.Atan(Data.Blocks[i + 1].Pitch);
								Transformation GroundTransformation2 = new Transformation(TrackYaw2, 0.0, 0.0);
								Transformation TrackTransformation2 = new Transformation(TrackYaw2, TrackPitch2, 0.0);
								 */
								double x2 = Data.Blocks[i + 1].Rails[railKey].RailEnd.X;
								double y2 = Data.Blocks[i + 1].Rails[railKey].RailEnd.Y;
								Vector3 offset2 = new Vector3(Direction2.Y * x2, y2, -Direction2.X * x2);
								Vector3 pos2 = Position2 + offset2;
								Vector3 r = new Vector3(pos2.X - pos.X, pos2.Y - pos.Y, pos2.Z - pos.Z);
								r.Normalize();
								RailTransformation.Z = r;
								RailTransformation.X = new Vector3(r.Z, 0.0, -r.X);
								Normalize(ref RailTransformation.X.X, ref RailTransformation.X.Z);
								RailTransformation.Y = Vector3.Cross(RailTransformation.Z, RailTransformation.X);
								planar = Math.Atan(Data.Blocks[i + 1].Rails[railKey].MidPoint.X / c);
								updown = Math.Atan(Data.Blocks[i + 1].Rails[railKey].MidPoint.Y / c);
							}
							else
							{
								planar = 0.0;
								updown = 0.0;
								RailTransformation = new Transformation(TrackTransformation, 0.0, 0.0, 0.0);
							}

							CurrentRoute.Tracks[railKey].Elements[n].StartingTrackPosition = StartingDistance;
							CurrentRoute.Tracks[railKey].Elements[n].WorldPosition = pos;
							CurrentRoute.Tracks[railKey].Elements[n].WorldDirection = RailTransformation.Z;
							CurrentRoute.Tracks[railKey].Elements[n].WorldSide = RailTransformation.X;
							CurrentRoute.Tracks[railKey].Elements[n].WorldUp = RailTransformation.Y;
							CurrentRoute.Tracks[railKey].Elements[n].CurveCant = Data.Blocks[i].Rails[railKey].CurveCant;
							CurrentRoute.Tracks[railKey].Elements[n].AdhesionMultiplier = Data.Blocks[i].Rails[railKey].AdhesionMultiplier;
							CurrentRoute.Tracks[railKey].Elements[n].IsDriveable = Data.Blocks[i].Rails[railKey].IsDriveable;
						}

						if (!PreviewOnly)
						{
							if (railKey > 0 && !Data.Blocks[i].Rails[railKey].RailStarted)
							{
								if (!Data.Blocks[i].Rails[railKey].RailStartRefreshed && Data.Blocks[i].Rails[railKey].RailEnded && !CurrentRoute.Tracks[railKey].Elements[n].ContainsSwitch)
								{
									// NOTE: Can't issue a railend command in the same block as a switch.
									CurrentRoute.Tracks[railKey].Elements[n].Events.Add(new TrackEndEvent(Plugin.CurrentHost, Data.BlockInterval));
								}

								//In order to run on other tracks, we need to calculate the positions and stuff, so continue after here instead
								continue;
							}

							if (Data.Structure.RailObjects.ContainsKey(Data.Blocks[i].RailType[railKey]))
							{
								Data.Structure.RailObjects[Data.Blocks[i].RailType[railKey]]?.CreateObject(pos, RailTransformation, StartingDistance, EndingDistance, StartingDistance);
							}

							// points of interest
							for (int k = 0; k < Data.Blocks[i].PointsOfInterest.Length; k++)
							{
								if (Data.Blocks[i].PointsOfInterest[k].RailIndex == railKey)
								{
									double d = Data.Blocks[i].PointsOfInterest[k].TrackPosition - StartingDistance;
									double x = Data.Blocks[i].PointsOfInterest[k].Position.X;
									double y = Data.Blocks[i].PointsOfInterest[k].Position.Y;
									int m = CurrentRoute.PointsOfInterest.Length;
									Array.Resize(ref CurrentRoute.PointsOfInterest, m + 1);
									CurrentRoute.PointsOfInterest[m].TrackPosition = Data.Blocks[i].PointsOfInterest[k].TrackPosition;
									if (i < Data.Blocks.Count - 1 && Data.Blocks[i + 1].Rails.ContainsKey(railKey))
									{
										Vector2 trackOffset = Data.Blocks[i].Rails[railKey].MidPoint;
										trackOffset.X = Data.Blocks[i].Rails[railKey].RailStart.X + d / Data.BlockInterval * trackOffset.X;
										trackOffset.Y = Data.Blocks[i].Rails[railKey].RailStart.Y + d / Data.BlockInterval * trackOffset.Y;
										CurrentRoute.PointsOfInterest[m].TrackOffset = new Vector3(x + trackOffset.X, y + trackOffset.Y, 0.0);
									}
									else
									{
										double dx = Data.Blocks[i].Rails[railKey].RailStart.X;
										double dy = Data.Blocks[i].Rails[railKey].RailStart.Y;
										CurrentRoute.PointsOfInterest[m].TrackOffset = new Vector3(x + dx, y + dy, 0.0);
									}

									CurrentRoute.PointsOfInterest[m].TrackYaw = Data.Blocks[i].PointsOfInterest[k].Yaw + planar;
									CurrentRoute.PointsOfInterest[m].TrackPitch = Data.Blocks[i].PointsOfInterest[k].Pitch + updown;
									CurrentRoute.PointsOfInterest[m].TrackRoll = Data.Blocks[i].PointsOfInterest[k].Roll;
									CurrentRoute.PointsOfInterest[m].Text = Data.Blocks[i].PointsOfInterest[k].Text;
								}
							}

							// poles
							if (Data.Blocks[i].RailPole.Length > railKey)
							{
								Data.Blocks[i].RailPole[railKey].Create(Data.Structure.Poles, pos, RailTransformation, Direction, planar, updown, StartingDistance, EndingDistance);
							}

							// walls
							if (Data.Blocks[i].RailWall.ContainsKey(railKey))
							{
								Data.Blocks[i].RailWall[railKey].Create(pos, RailTransformation, StartingDistance, EndingDistance);
							}

							// dikes
							if (Data.Blocks[i].RailDike.ContainsKey(railKey))
							{
								Data.Blocks[i].RailDike[railKey].Create(pos, RailTransformation, StartingDistance, EndingDistance);
							}

							// sounds
							for (int k = 0; k < Data.Blocks[i].SoundEvents.Length; k++)
							{
								if (railKey == Data.Blocks[i].SoundEvents[k].RailIndex)
								{
									Data.Blocks[i].SoundEvents[k].Create(pos, StartingDistance, Direction, planar, updown);
								}
							}

							// forms
							for (int k = 0; k < Data.Blocks[i].Forms.Length; k++)
							{
								// primary rail
								if (Data.Blocks[i].Forms[k].PrimaryRail == railKey)
								{
									Data.Blocks[i].Forms[k].CreatePrimaryRail(Data.Blocks[i], Data.Blocks[i + 1], pos, RailTransformation, StartingDistance, EndingDistance);
								}

								// secondary rail
								if (Data.Blocks[i].Forms[k].SecondaryRail == railKey)
								{
									Data.Blocks[i].Forms[k].CreateSecondaryRail(Data.Blocks[i], pos, RailTransformation, StartingDistance, EndingDistance);
								}
							}

							// cracks
							for (int k = 0; k < Data.Blocks[i].Cracks.Length; k++)
							{
								Data.Blocks[i].Cracks[k].Create(railKey, RailTransformation, pos, Data.Blocks[i], Data.Blocks[i + 1], Data.Structure, StartingDistance, EndingDistance);
							}

							// free objects
							if (Data.Blocks[i].RailFreeObj.ContainsKey(railKey))
							{
								for (int k = 0; k < Data.Blocks[i].RailFreeObj[railKey].Count; k++)
								{
									Data.Blocks[i].RailFreeObj[railKey][k].CreateRailAligned(Data.Structure.FreeObjects, new Vector3(pos), RailTransformation, StartingDistance, EndingDistance);
								}
							}

							// pattern objects
							if (railInBlock == 0)
							{
								for (int k = 0; k < Data.Blocks[i].PatternObjs.Count; k++)
								{
									int key = Data.Blocks[i].PatternObjs.ElementAt(k).Key;
									if (Data.Blocks[i].PatternObjs[key].Interval <= 0)
									{
										continue;
									}

									// patterns key off rail 0
									while (Data.Blocks[i].PatternObjs[key].LastPlacement + Data.Blocks[i].PatternObjs[key].Interval < (i + 1) * Data.BlockInterval)
									{
										if (!Data.Blocks[i].PatternObjs[key].CreateRailAligned(Data.Structure.FreeObjects, new Vector3(pos), RailTransformation, StartingDistance, EndingDistance))
										{
											break;
										}
									}

									if (i < Data.Blocks.Count - 1 && Data.Blocks[i + 1].PatternObjs.ContainsKey(key))
									{
										Data.Blocks[i + 1].PatternObjs[key].LastPlacement = Data.Blocks[i].PatternObjs[key].LastPlacement;
										Data.Blocks[i + 1].PatternObjs[key].LastType = Data.Blocks[i].PatternObjs[key].LastType;
									}
								}
							}

							// transponder objects
							if (railKey == 0)
							{
								for (int k = 0; k < Data.Blocks[i].Transponders.Length; k++)
								{
									double b = 0.25 + 0.75 * Data.GetBrightness(Data.Blocks[i].Transponders[k].TrackPosition);
									Data.Blocks[i].Transponders[k].Create(new Vector3(pos), RailTransformation, StartingDistance, EndingDistance, b, Data.Structure.Beacon);
								}

								for (int k = 0; k < Data.Blocks[i].DestinationChanges.Length; k++)
								{
									Data.Blocks[i].DestinationChanges[k].Create(new Vector3(pos), RailTransformation, StartingDistance, EndingDistance, Data.Structure.Beacon);
								}

								for (int k = 0; k < Data.Blocks[i].HornBlows.Length; k++)
								{
									Data.Blocks[i].HornBlows[k].Create(new Vector3(pos), RailTransformation, StartingDistance, EndingDistance, Data.Structure.Beacon);
								}
							}

							// sections/signals/transponders
							if (railKey == 0)
							{
								// signals
								for (int k = 0; k < Data.Blocks[i].Signals.Length; k++)
								{
									Data.Blocks[i].Signals[k].Create(new Vector3(pos), RailTransformation, StartingDistance, EndingDistance, 0.27 + 0.75 * Data.GetBrightness(Data.Blocks[i].Signals[k].TrackPosition));
								}

								// sections
								for (int k = 0; k < Data.Blocks[i].Sections.Length; k++)
								{
									Data.Blocks[i].Sections[k].Create(CurrentRoute, Data.Blocks, i, n, Data.SignalSpeeds, StartingDistance, Data.BlockInterval);
								}

								// transponders introduced after corresponding sections
								for (int l = 0; l < Data.Blocks[i].Transponders.Length; l++)
								{
									Data.Blocks[i].Transponders[l].CreateEvent(ref CurrentRoute.Tracks[0].Elements[n], StartingDistance);
								}

								for (int l = 0; l < Data.Blocks[i].LightingChanges.Length; l++)
								{
									Data.Blocks[i].LightingChanges[l].Create(ref CurrentRoute.Tracks[0].Elements[n], Data.Structure.LightDefinitions);
								}
							}

							// limit
							for (int k = 0; k < Data.Blocks[i].Limits.Length; k++)
							{
								if (railKey == Data.Blocks[i].Limits[k].RailIndex)
								{
									double b = 0.25 + 0.75 * Data.GetBrightness(Data.Blocks[i].Limits[k].TrackPosition);
									Data.Blocks[i].Limits[k].Create(new Vector3(pos), RailTransformation, StartingDistance, EndingDistance, b, Data.UnitOfSpeed);
								}
							}

							// stop
							if (railKey == 0)
							{
								for (int k = 0; k < Data.Blocks[i].StopPositions.Length; k++)
								{
									double b = 0.25 + 0.75 * Data.GetBrightness(Data.Blocks[i].StopPositions[k].TrackPosition);
									Data.Blocks[i].StopPositions[k].Create(new Vector3(pos), RailTransformation, StartingDistance, EndingDistance, b);
								}
							}
						}
					}
				}

				// finalize block
				Position.X += Direction.X * c;
				Position.Y += h;
				Position.Z += Direction.Y * c;
				if (a != 0.0)
				{
					Direction.Rotate(Math.Cos(-a), Math.Sin(-a));
				}
			}
			// orphaned transponders
			if (!PreviewOnly)
			{
				for (int i = Data.FirstUsedBlock; i < Data.Blocks.Count; i++)
				{
					for (int j = 0; j < Data.Blocks[i].Transponders.Length; j++)
					{
						if (Data.Blocks[i].Transponders[j].Type != -1)
						{
							int n = i - Data.FirstUsedBlock;
							double d = Data.Blocks[i].Transponders[j].TrackPosition - CurrentRoute.Tracks[0].Elements[n].StartingTrackPosition;
							int s = Data.Blocks[i].Transponders[j].SectionIndex;
							if (s >= 0) s = -1;
							CurrentRoute.Tracks[0].Elements[n].Events.Add(new TransponderEvent(CurrentRoute, d, Data.Blocks[i].Transponders[j].Type, Data.Blocks[i].Transponders[j].Data, s, Data.Blocks[i].Transponders[j].ClipToFirstRedSection));
							Data.Blocks[i].Transponders[j].Type = -1;
						}
					}
					// Destination Change Events
					for (int j = 0; j < Data.Blocks[i].DestinationChanges.Length; j++)
					{
						int n = i - Data.FirstUsedBlock;
						double d = Data.Blocks[i].DestinationChanges[j].TrackPosition - CurrentRoute.Tracks[0].Elements[n].StartingTrackPosition;
						CurrentRoute.Tracks[0].Elements[n].Events.Add(new RouteManager2.Events.DestinationEvent(d, Data.Blocks[i].DestinationChanges[j].Type, Data.Blocks[i].DestinationChanges[j].NextDestination, Data.Blocks[i].DestinationChanges[j].PreviousDestination, Data.Blocks[i].DestinationChanges[j].TriggerOnce));
					}
					for (int j = 0; j < Data.Blocks[i].HornBlows.Length; j++)
					{
						int n = i - Data.FirstUsedBlock;
						double d = Data.Blocks[i].HornBlows[j].TrackPosition - CurrentRoute.Tracks[0].Elements[n].StartingTrackPosition;
						CurrentRoute.Tracks[0].Elements[n].Events.Add(new RouteManager2.Events.HornBlowEvent(d, Data.Blocks[i].HornBlows[j].Type, Data.Blocks[i].HornBlows[j].TriggerOnce));
					}
				}
			}
			// insert station end events
			for (int i = 0; i < CurrentRoute.Stations.Length; i++)
			{
				int j = CurrentRoute.Stations[i].Stops.Length - 1;
				if (j >= 0)
				{
					double p = CurrentRoute.Stations[i].Stops[j].TrackPosition + CurrentRoute.Stations[i].Stops[j].ForwardTolerance + Data.BlockInterval;
					int k = (int)Math.Floor(p / Data.BlockInterval) - Data.FirstUsedBlock;
					if (k >= 0 && k < Data.Blocks.Count)
					{
						double d = p - (k + Data.FirstUsedBlock) * Data.BlockInterval;
						if (CurrentRoute.Tracks[0].Direction == TrackDirection.Reverse)
						{
							CurrentRoute.Tracks[0].Elements[k].Events.Add(new StationStartEvent(CurrentRoute, d, i));
						}
						else
						{
							CurrentRoute.Tracks[0].Elements[k].Events.Add(new StationEndEvent(Plugin.CurrentHost, CurrentRoute, d, i));
						}
						
					}
				}
			}
			// create default point of interests
			if (CurrentRoute.PointsOfInterest.Length == 0)
			{
				CurrentRoute.PointsOfInterest = new RouteManager2.PointOfInterest[CurrentRoute.Stations.Length];
				int n = 0;
				for (int i = 0; i < CurrentRoute.Stations.Length; i++)
				{
					if (CurrentRoute.Stations[i].Stops.Length != 0)
					{
						CurrentRoute.PointsOfInterest[n].Text = CurrentRoute.Stations[i].Name;
						CurrentRoute.PointsOfInterest[n].TrackPosition = CurrentRoute.Stations[i].Stops[0].TrackPosition;
						CurrentRoute.PointsOfInterest[n].TrackOffset = new Vector3(0.0, 2.8, 0.0);
						if (CurrentRoute.Stations[i].OpenLeftDoors && !CurrentRoute.Stations[i].OpenRightDoors)
						{
							CurrentRoute.PointsOfInterest[n].TrackOffset.X = -2.5;
						}
						else if (!CurrentRoute.Stations[i].OpenLeftDoors && CurrentRoute.Stations[i].OpenRightDoors)
						{
							CurrentRoute.PointsOfInterest[n].TrackOffset.X = 2.5;
						}
						n++;
					}
				}
				Array.Resize(ref CurrentRoute.PointsOfInterest, n);
			}
			// convert block-based cant into point-based cant
			for (int ii = 0; ii < CurrentRoute.Tracks.Count; ii++)
			{
				int i = CurrentRoute.Tracks.ElementAt(ii).Key;
				for (int j = CurrentTrackLength - 1; j >= 1; j--)
				{
					if (CurrentRoute.Tracks[i].Elements[j].CurveCant == 0.0)
					{
						CurrentRoute.Tracks[i].Elements[j].CurveCant = CurrentRoute.Tracks[i].Elements[j - 1].CurveCant;
					}
					else if (CurrentRoute.Tracks[i].Elements[j - 1].CurveCant != 0.0)
					{
						if (Math.Sign(CurrentRoute.Tracks[i].Elements[j - 1].CurveCant) == Math.Sign(CurrentRoute.Tracks[i].Elements[j].CurveCant))
						{
							if (Math.Abs(CurrentRoute.Tracks[i].Elements[j - 1].CurveCant) > Math.Abs(CurrentRoute.Tracks[i].Elements[j].CurveCant))
							{
								CurrentRoute.Tracks[i].Elements[j].CurveCant = CurrentRoute.Tracks[i].Elements[j - 1].CurveCant;
							}
						}
						else
						{
							CurrentRoute.Tracks[i].Elements[j].CurveCant = 0.5 * (CurrentRoute.Tracks[i].Elements[j].CurveCant + CurrentRoute.Tracks[i].Elements[j - 1].CurveCant);
						}
					}
				}
			}
			// finalize
			for (int ii = 0; ii < CurrentRoute.Tracks.Count; ii++)
			{
				int i = CurrentRoute.Tracks.ElementAt(ii).Key;
				Array.Resize(ref CurrentRoute.Tracks[i].Elements, CurrentTrackLength);
			}
			for (int i = 0; i < CurrentRoute.Stations.Length; i++)
			{
				if (CurrentRoute.Stations[i].Stops.Length == 0 && CurrentRoute.Stations[i].StopMode != StationStopMode.AllPass)
				{
					Plugin.CurrentHost.AddMessage(MessageType.Warning, false, "Station " + CurrentRoute.Stations[i].Name + " expects trains to stop but does not define stop points at track position " + CurrentRoute.Stations[i].DefaultTrackPosition.ToString(Culture) + " in file " + FileName);
					CurrentRoute.Stations[i].StopMode = StationStopMode.AllPass;
				}

				switch (CurrentRoute.Stations[i].Type)
				{
					case StationType.ChangeEnds:
						if (i == 0)
						{
							Plugin.CurrentHost.AddMessage(MessageType.Warning, false, "Station " + CurrentRoute.Stations[i].Name + " is marked as \"change ends\" but is the first station in file " + FileName);
							CurrentRoute.Stations[i].Type = StationType.Normal;
							break;
						}
						if (i < CurrentRoute.Stations.Length - 1)
						{
							if (CurrentRoute.Stations[i + 1].StopMode != StationStopMode.AllStop)
							{
								Plugin.CurrentHost.AddMessage(MessageType.Warning, false, "Station " + CurrentRoute.Stations[i].Name + " is marked as \"change ends\" but the subsequent station does not expect all trains to stop in file " + FileName);
								CurrentRoute.Stations[i + 1].StopMode = StationStopMode.AllStop;
							}
						}
						else
						{
							Plugin.CurrentHost.AddMessage(MessageType.Warning, false, "Station " + CurrentRoute.Stations[i].Name + " is marked as \"change ends\" but there is no subsequent station defined in file " + FileName);
							CurrentRoute.Stations[i].Type = StationType.Terminal;
						}
						break;
					case StationType.Jump:
						if (i == 0)
						{
							Plugin.CurrentHost.AddMessage(MessageType.Warning, false, "Station " + CurrentRoute.Stations[i].Name + " is marked as a \"jump trigger\" but is the first station in file " + FileName);
							CurrentRoute.Stations[i].Type = StationType.Normal;
							break;
						}
						if (CurrentRoute.Stations[i].JumpIndex < CurrentRoute.Stations.Length)
						{
							if (CurrentRoute.Stations[CurrentRoute.Stations[i].JumpIndex].StopMode != StationStopMode.AllStop)
							{
								Plugin.CurrentHost.AddMessage(MessageType.Warning, false, "Station " + CurrentRoute.Stations[i].Name + " is marked as a \"jump trigger\" but the target station does not expect all trains to stop in file " + FileName);
								CurrentRoute.Stations[CurrentRoute.Stations[i].JumpIndex].StopMode = StationStopMode.AllStop;
							}
						}
						else
						{
							Plugin.CurrentHost.AddMessage(MessageType.Warning, false, "Station " + CurrentRoute.Stations[i].Name + " is marked as a \"jump trigger\" but the target station does not exist in file " + FileName);
							CurrentRoute.Stations[i].Type = StationType.Terminal;
						}
						break;
					case StationType.Terminal:
						if (i == 0)
						{
							Plugin.CurrentHost.AddMessage(MessageType.Warning, false, "Station " + CurrentRoute.Stations[i].Name + " is marked as \"terminal\" but is the first station in file " + FileName);
							CurrentRoute.Stations[i].Type = StationType.Normal;
						}
						break;
				}
			}
			if (CurrentRoute.Stations.Length != 0)
			{
				if (CurrentRoute.Tracks[0].Direction == TrackDirection.Reverse)
				{
					CurrentRoute.Stations[0].Type = StationType.Terminal;
					if (CurrentRoute.Stations[CurrentRoute.Stations.Length - 1].Type == StationType.Terminal)
					{
						CurrentRoute.Stations[CurrentRoute.Stations.Length - 1].Type = StationType.Normal;
					}
				}
				else
				{
					CurrentRoute.Stations[CurrentRoute.Stations.Length - 1].Type = StationType.Terminal;
				}
				
			}
			
			if (CurrentRoute.Tracks[0].Elements.Length != 0)
			{
				int n = CurrentRoute.Tracks[0].Elements.Length - 1;
				CurrentRoute.Tracks[0].Elements[n].Events.Add(new TrackEndEvent(Plugin.CurrentHost, Data.BlockInterval));
			}
			// insert compatibility beacons
			if (!PreviewOnly)
			{
				List<TransponderEvent> transponders = new List<TransponderEvent>();
				bool atc = false;
				for (int i = 0; i < CurrentRoute.Tracks[0].Elements.Length; i++)
				{
					for (int j = 0; j < CurrentRoute.Tracks[0].Elements[i].Events.Count; j++)
					{
						if (!atc)
						{
							if (CurrentRoute.Tracks[0].Elements[i].Events[j] is StationStartEvent stationStart)
							{
								if (CurrentRoute.Stations[stationStart.StationIndex].SafetySystem == SafetySystem.Atc)
								{
									CurrentRoute.Tracks[0].Elements[i].Events.Add(new TransponderEvent(CurrentRoute, 0.0, TransponderTypes.AtcTrackStatus, 0, 0, false));
									CurrentRoute.Tracks[0].Elements[i].Events.Add(new TransponderEvent(CurrentRoute, 0.0, TransponderTypes.AtcTrackStatus, 1, 0, false));
									atc = true;
								}
							}
						}
						else
						{
							if (CurrentRoute.Tracks[0].Elements[i].Events[j] is StationStartEvent stationStart)
							{
								if (CurrentRoute.Stations[stationStart.StationIndex].SafetySystem == SafetySystem.Ats)
								{
									CurrentRoute.Tracks[0].Elements[i].Events.Add(new TransponderEvent(CurrentRoute, 0.0, TransponderTypes.AtcTrackStatus, 2, 0, false));
									CurrentRoute.Tracks[0].Elements[i].Events.Add(new TransponderEvent(CurrentRoute, 0.0, TransponderTypes.AtcTrackStatus, 3, 0, false));
								}
							}
							else if (CurrentRoute.Tracks[0].Elements[i].Events[j] is StationEndEvent stationEnd)
							{
								if (CurrentRoute.Stations[stationEnd.StationIndex].SafetySystem == SafetySystem.Atc)
								{
									CurrentRoute.Tracks[0].Elements[i].Events.Add(new TransponderEvent(CurrentRoute, 0.0, TransponderTypes.AtcTrackStatus, 1, 0, false));
									CurrentRoute.Tracks[0].Elements[i].Events.Add(new TransponderEvent(CurrentRoute, 0.0, TransponderTypes.AtcTrackStatus, 2, 0, false));
								}
								else if (CurrentRoute.Stations[stationEnd.StationIndex].SafetySystem == SafetySystem.Ats)
								{
									CurrentRoute.Tracks[0].Elements[i].Events.Add(new TransponderEvent(CurrentRoute, 0.0, TransponderTypes.AtcTrackStatus, 3, 0, false));
									CurrentRoute.Tracks[0].Elements[i].Events.Add(new TransponderEvent(CurrentRoute, 0.0, TransponderTypes.AtcTrackStatus, 0, 0, false));
									atc = false;
								}
							}
							else if (CurrentRoute.Tracks[0].Elements[i].Events[j] is LimitChangeEvent limit)
							{
								int speed = (int)Math.Round(Math.Min(4095.0, 3.6 * limit.NextSpeedLimit));
								int distance = Math.Min(1048575, (int)Math.Round(CurrentRoute.Tracks[0].Elements[i].StartingTrackPosition + limit.TrackPositionDelta));
								unchecked
								{
									int value = (int)((uint)speed | ((uint)distance << 12));
									transponders.Add(new TransponderEvent(CurrentRoute, 0.0, TransponderTypes.AtcSpeedLimit, value, 0, false));
								}
							}
						}
						if (CurrentRoute.Tracks[0].Elements[i].Events[j] is TransponderEvent transponder)
						{
							if (transponder.Type == (int)TransponderTypes.InternalAtsPTemporarySpeedLimit)
							{
								int speed = Math.Min(4095, transponder.Data);
								int distance = Math.Min(1048575, (int)Math.Round(CurrentRoute.Tracks[0].Elements[i].StartingTrackPosition + transponder.TrackPositionDelta));
								unchecked
								{
									int value = (int)((uint)speed | ((uint)distance << 12));
									transponders.Add(new TransponderEvent(CurrentRoute, 0.0, TransponderTypes.AtsPTemporarySpeedLimit, value, 0, false));
								}
							}
						}
					}
				}
				for (int i = 0; i < transponders.Count; i++)
				{
					CurrentRoute.Tracks[0].Elements[0].Events.Add(transponders[i]);
				}
			}
			// cant
			if (!PreviewOnly)
			{
				ComputeCantTangents();
				int subdivisions = (int)Math.Floor(Data.BlockInterval / 5.0);
				if (subdivisions >= 2)
				{
					if (Data.TurnUsed)
					{
						Plugin.CurrentRoute.Tracks[0].SmoothTurns(subdivisions, Plugin.CurrentHost);
					}
					ComputeCantTangents();
				}
			}

			if (!PreviewOnly)
			{
				// Create and place all scripted trains *last* to ensure that all required rails etc. are present
				if (Plugin.TrainManager.TFOs == null)
				{
					Plugin.TrainManager.TFOs = new List<AbstractTrain>();
				}
				for (int i = 0; i < Data.ScriptedTrainFiles.Count; i++)
				{
					AbstractTrain train = Plugin.CurrentHost.ParseTrackFollowingObject(ObjectPath, Data.ScriptedTrainFiles[i]);
					if (train != null)
					{
						// loading the train may fail
						Plugin.TrainManager.TFOs.Add(train);
					}
					
				}
			}
			
		}

		private void ComputeCantTangents()
		{
			for (int ii = 0; ii < CurrentRoute.Tracks.Count; ii++)
			{
				int i = CurrentRoute.Tracks.ElementAt(ii).Key;
				CurrentRoute.Tracks[i].ComputeCantTangents();
			}
		}
	}
}
