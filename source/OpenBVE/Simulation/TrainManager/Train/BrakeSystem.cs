using System;
using OpenBve.BrakeSystems;

namespace OpenBve
{
	public static partial class TrainManager
	{
		public partial class Train
		{
			/// <summary>Updates the brake system for the entire train</summary>
			/// <param name="TimeElapsed">The frame time elapsed</param>
			/// <param name="DecelerationDueToBrake">An array containing the deceleration figures generated by the brake system of each car in the train</param>
			/// <param name="DecelerationDueToMotor">An array containing the deceleration figures generated by the motor of each car in the train (If it is a motor car)</param>
			private void UpdateBrakeSystem(double TimeElapsed, out double[] DecelerationDueToBrake, out double[] DecelerationDueToMotor)
			{
				// individual brake systems
				DecelerationDueToBrake = new double[Cars.Length];
				DecelerationDueToMotor = new double[Cars.Length];
				for (int i = 0; i < Cars.Length; i++)
				{
					UpdateBrakeSystem(i, TimeElapsed, out DecelerationDueToBrake[i], out DecelerationDueToMotor[i]);
				}
				// brake pipe pressure distribution dummy (just averages)
				double TotalPressure = 0.0;
				for (int i = 0; i < Cars.Length; i++)
				{
					if (i > 0)
					{
						if (Cars[i - 1].Derailed | Cars[i].Derailed)
						{
							Cars[i].CarBrake.brakePipe.CurrentPressure -= Game.BrakePipeLeakRate * TimeElapsed;
							if (Cars[i].CarBrake.brakePipe.CurrentPressure < 0.0) Cars[i].CarBrake.brakePipe.CurrentPressure = 0.0;
						}
					}
					if (i < Cars.Length - 1)
					{
						if (Cars[i].Derailed | Cars[i + 1].Derailed)
						{
							Cars[i].CarBrake.brakePipe.CurrentPressure -= Game.BrakePipeLeakRate * TimeElapsed;
							if (Cars[i].CarBrake.brakePipe.CurrentPressure < 0.0) Cars[i].CarBrake.brakePipe.CurrentPressure = 0.0;
						}
					}
					TotalPressure += Cars[i].CarBrake.brakePipe.CurrentPressure;
				}
				double AveragePressure = TotalPressure / (double)Cars.Length;
				for (int i = 0; i < Cars.Length; i++)
				{
					Cars[i].CarBrake.brakePipe.CurrentPressure = AveragePressure;
				}
			}

			/// <summary>Updates the brake system for a car within this train</summary>
			/// <remarks>This must remain a property of the train, for easy access to various base properties</remarks>
			/// <param name="CarIndex">The induvidual car</param>
			/// <param name="TimeElapsed">The frame time elapsed</param>
			/// <param name="DecelerationDueToBrake">The total brake deceleration this car provides</param>
			/// <param name="DecelerationDueToMotor">The total motor deceleration this car provides</param>
			private void UpdateBrakeSystem(int CarIndex, double TimeElapsed, out double DecelerationDueToBrake, out double DecelerationDueToMotor)
			{
				DecelerationDueToBrake = 0.0;
				// air compressor
				if (Cars[CarIndex].CarBrake.brakeType == BrakeType.Main)
				{
					if (Cars[CarIndex].CarBrake.airCompressor.Enabled)
					{
						if (Cars[CarIndex].CarBrake.mainReservoir.CurrentPressure > Cars[CarIndex].CarBrake.mainReservoir.MaximumPressure)
						{
							Cars[CarIndex].CarBrake.airCompressor.Enabled = false;
							Cars[CarIndex].Sounds.CpLoopStarted = false;
							Sounds.SoundBuffer buffer = Cars[CarIndex].Sounds.CpEnd.Buffer;
							if (buffer != null)
							{
								OpenBveApi.Math.Vector3 pos = Cars[CarIndex].Sounds.CpEnd.Position;
								Sounds.PlaySound(buffer, 1.0, 1.0, pos, this, CarIndex, false);
							}

							buffer = Cars[CarIndex].Sounds.CpLoop.Buffer;
							if (buffer != null)
							{
								Sounds.StopSound(Cars[CarIndex].Sounds.CpLoop.Source);
							}
						}
						else
						{
							Cars[CarIndex].CarBrake.mainReservoir.CurrentPressure += Cars[CarIndex].CarBrake.airCompressor.Rate * TimeElapsed;
							if (!Cars[CarIndex].Sounds.CpLoopStarted && Game.SecondsSinceMidnight > Cars[CarIndex].Sounds.CpStartTimeStarted + 5.0)
							{
								Cars[CarIndex].Sounds.CpLoopStarted = true;
								Sounds.SoundBuffer buffer = Cars[CarIndex].Sounds.CpLoop.Buffer;
								if (buffer != null)
								{
									OpenBveApi.Math.Vector3 pos = Cars[CarIndex].Sounds.CpLoop.Position;
									Cars[CarIndex].Sounds.CpLoop.Source = Sounds.PlaySound(buffer, 1.0, 1.0, pos, this, CarIndex, true);
								}
							}
						}
					}
					else
					{
						if (Cars[CarIndex].CarBrake.mainReservoir.CurrentPressure < Cars[CarIndex].CarBrake.mainReservoir.MinimumPressure)
						{
							Cars[CarIndex].CarBrake.airCompressor.Enabled = true;
							Cars[CarIndex].Sounds.CpStartTimeStarted = Game.SecondsSinceMidnight;
							Sounds.SoundBuffer buffer = Cars[CarIndex].Sounds.CpStart.Buffer;
							if (buffer != null)
							{
								OpenBveApi.Math.Vector3 pos = Cars[CarIndex].Sounds.CpStart.Position;
								Sounds.PlaySound(buffer, 1.0, 1.0, pos, this, CarIndex, false);
							}
						}
					}
				}

				if (CarIndex == DriverCar && Handles.HasLocoBrake)
				{
					switch (Handles.LocoBrakeType)
					{
						case LocoBrakeType.Independant:
							//With an independant Loco brake, we always want to use this handle
							Cars[CarIndex].CarBrake.Update(TimeElapsed, Cars[DriverCar].Specs.CurrentSpeed, Handles.LocoBrake, out DecelerationDueToBrake);
							break;
						case LocoBrakeType.Combined:
							if (Handles.LocoBrake is LocoBrakeHandle && Handles.Brake is NotchedHandle)
							{
								//Both handles are of the notched type
								if (Handles.Brake.MaximumNotch == Handles.LocoBrake.MaximumNotch)
								{
									//Identical number of notches, so return the handle with the higher setting
									if (Handles.LocoBrake.Actual >= Handles.Brake.Actual)
									{
										Cars[CarIndex].CarBrake.Update(TimeElapsed, Cars[DriverCar].Specs.CurrentSpeed, Handles.LocoBrake, out DecelerationDueToBrake);
									}
									else
									{
										Cars[CarIndex].CarBrake.Update(TimeElapsed, Cars[DriverCar].Specs.CurrentSpeed, Handles.Brake, out DecelerationDueToBrake);
									}
								}
								else if (Handles.Brake.MaximumNotch > Handles.LocoBrake.MaximumNotch)
								{
									double nc = ((double) Handles.LocoBrake.Actual / Handles.LocoBrake.MaximumNotch) * Handles.Brake.MaximumNotch;
									if (nc > Handles.Brake.Actual)
									{
										Cars[CarIndex].CarBrake.Update(TimeElapsed, Cars[DriverCar].Specs.CurrentSpeed, Handles.LocoBrake, out DecelerationDueToBrake);
									}
									else
									{
										Cars[CarIndex].CarBrake.Update(TimeElapsed, Cars[DriverCar].Specs.CurrentSpeed, Handles.Brake, out DecelerationDueToBrake);
									}
								}
								else
								{
									double nc = ((double) Handles.Brake.Actual / Handles.Brake.MaximumNotch) * Handles.LocoBrake.MaximumNotch;
									if (nc > Handles.LocoBrake.Actual)
									{
										Cars[CarIndex].CarBrake.Update(TimeElapsed, Cars[DriverCar].Specs.CurrentSpeed, Handles.Brake, out DecelerationDueToBrake);
									}
									else
									{
										Cars[CarIndex].CarBrake.Update(TimeElapsed, Cars[DriverCar].Specs.CurrentSpeed, Handles.LocoBrake, out DecelerationDueToBrake);
									}
								}
							}
							else if (Handles.LocoBrake is LocoAirBrakeHandle && Handles.Brake is AirBrakeHandle)
							{
								if (Handles.LocoBrake.Actual < Handles.Brake.Actual)
								{
									Cars[CarIndex].CarBrake.Update(TimeElapsed, Cars[DriverCar].Specs.CurrentSpeed, Handles.Brake, out DecelerationDueToBrake);
								}
								else
								{
									Cars[CarIndex].CarBrake.Update(TimeElapsed, Cars[DriverCar].Specs.CurrentSpeed, Handles.LocoBrake, out DecelerationDueToBrake);
								}
							}
							else
							{
								double p, tp;
								//Calculate the pressure differentials for the two handles
								if (Handles.LocoBrake is LocoAirBrakeHandle)
								{
									//Air brake handle
									p = Cars[CarIndex].CarBrake.brakeCylinder.CurrentPressure / Cars[CarIndex].CarBrake.brakeCylinder.ServiceMaximumPressure;
									tp = (Cars[CarIndex].CarBrake.brakeCylinder.ServiceMaximumPressure / Handles.Brake.MaximumNotch) * Handles.Brake.Actual;
								}
								else
								{
									//Notched handle
									p = Cars[CarIndex].CarBrake.brakeCylinder.CurrentPressure / Cars[CarIndex].CarBrake.brakeCylinder.ServiceMaximumPressure;
									tp = (Cars[CarIndex].CarBrake.brakeCylinder.ServiceMaximumPressure / Handles.LocoBrake.MaximumNotch) * Handles.LocoBrake.Actual;
								}

								if (p < tp)
								{
									Cars[CarIndex].CarBrake.Update(TimeElapsed, Cars[DriverCar].Specs.CurrentSpeed, Handles.Brake, out DecelerationDueToBrake);
								}
								else
								{
									Cars[CarIndex].CarBrake.Update(TimeElapsed, Cars[DriverCar].Specs.CurrentSpeed, Handles.LocoBrake, out DecelerationDueToBrake);
								}
							}
							break;
						case LocoBrakeType.Blocking:
							if (Handles.LocoBrake.Actual != 0)
							{
								Cars[CarIndex].CarBrake.Update(TimeElapsed, Cars[DriverCar].Specs.CurrentSpeed, Handles.LocoBrake, out DecelerationDueToBrake);
							}
							else
							{
								Cars[CarIndex].CarBrake.Update(TimeElapsed, Cars[DriverCar].Specs.CurrentSpeed, Handles.Brake, out DecelerationDueToBrake);
							}

							break;
					}

				}
				else
				{
					Cars[CarIndex].CarBrake.Update(TimeElapsed, Cars[DriverCar].Specs.CurrentSpeed, Handles.Brake, out DecelerationDueToBrake);
				}


				switch (Cars[CarIndex].CarBrake.airSound)
				{
					case AirSound.AirZero:
					{
						Sounds.SoundBuffer buffer = Cars[CarIndex].Sounds.AirZero.Buffer;
						if (buffer != null)
						{
							OpenBveApi.Math.Vector3 pos = Cars[CarIndex].Sounds.AirZero.Position;
							Sounds.PlaySound(buffer, 1.0, 1.0, pos, this, CarIndex, false);
						}

						break;
					}
					case AirSound.Air:
					{
						Sounds.SoundBuffer buffer = Cars[CarIndex].Sounds.Air.Buffer;
						if (buffer != null)
						{
							OpenBveApi.Math.Vector3 pos = Cars[CarIndex].Sounds.Air.Position;
							Sounds.PlaySound(buffer, 1.0, 1.0, pos, this, CarIndex, false);
						}
						break;
					}
					case AirSound.AirHigh:
					{
						Sounds.SoundBuffer buffer = Cars[CarIndex].Sounds.AirHigh.Buffer;
						if (buffer != null)
						{
							OpenBveApi.Math.Vector3 pos = Cars[CarIndex].Sounds.AirHigh.Position;
							Sounds.PlaySound(buffer, 1.0, 1.0, pos, this, CarIndex, false);
						}
						break;
					}
				}

				// deceleration provided by motor
				if (!(Cars[CarIndex].CarBrake is AutomaticAirBrake) && Math.Abs(Cars[CarIndex].Specs.CurrentSpeed) >= Cars[CarIndex].CarBrake.brakeControlSpeed & Handles.Reverser.Actual != 0 & !Handles.EmergencyBrake.Actual)
				{
					double f;
					if (Handles.LocoBrake.Actual != 0 && CarIndex == DriverCar)
					{
						f = (double) Handles.LocoBrake.Actual / (double) Handles.Brake.MaximumNotch;
					}
					else
					{
						f = (double) Handles.Brake.Actual / (double) Handles.Brake.MaximumNotch;
					}

					double a = Cars[CarIndex].Specs.MotorDeceleration;
					DecelerationDueToMotor = f * a;
				}
				else
				{
					DecelerationDueToMotor = 0.0;
				}

				// hold brake
				Cars[CarIndex].Specs.HoldBrake.Update(ref DecelerationDueToMotor, Handles.HoldBrake.Actual);
				{
					// rub sound
					Sounds.SoundBuffer buffer = Cars[CarIndex].Sounds.Rub.Buffer;
					if (buffer != null)
					{
						double spd = Math.Abs(Cars[CarIndex].Specs.CurrentSpeed);
						double pitch = 1.0 / (spd + 1.0) + 1.0;
						double gain = Cars[CarIndex].Derailed ? 0.0 : Cars[CarIndex].CarBrake.brakeCylinder.CurrentPressure / Cars[CarIndex].CarBrake.brakeCylinder.ServiceMaximumPressure;
						if (spd < 1.38888888888889)
						{
							double t = spd * spd;
							gain *= 1.5552 * t - 0.746496 * spd * t;
						}
						else if (spd > 12.5)
						{
							double t = spd - 12.5;
							const double fadefactor = 0.1;
							gain *= 1.0 / (fadefactor * t * t + 1.0);
						}

						if (Sounds.IsPlaying(Cars[CarIndex].Sounds.Rub.Source))
						{
							if (pitch > 0.01 & gain > 0.001)
							{
								Cars[CarIndex].Sounds.Rub.Source.Pitch = pitch;
								Cars[CarIndex].Sounds.Rub.Source.Volume = gain;
							}
							else
							{
								Sounds.StopSound(Cars[CarIndex].Sounds.Rub.Source);
							}
						}
						else if (pitch > 0.02 & gain > 0.01)
						{
							OpenBveApi.Math.Vector3 pos = Cars[CarIndex].Sounds.Rub.Position;
							Cars[CarIndex].Sounds.Rub.Source = Sounds.PlaySound(buffer, pitch, gain, pos, this, CarIndex, true);
						}
					}
				}
			}

		}
	}
}
