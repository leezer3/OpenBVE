using System;
using System.Diagnostics.Eventing.Reader;
using DavyKager;
using LibRender2.Texts;
using OpenBveApi;
using OpenBveApi.Trains;
using RouteManager2;
using RouteManager2.MessageManager;

namespace OpenBve
{
	/*
	 * This class holds the definitions for textual messages
	 */
	partial class MessageManager
	{
		/// <summary>Defines a textual message generated by the game</summary>
		internal class GameMessage : AbstractMessage
		{
			/// <summary>The internal (non-translated) string</summary>
			internal string InternalText;
			/// <summary>The action which triggered this message (route, speed limit etc.)</summary>
			internal MessageDependency Depencency;

			/// <summary>The font used for this message</summary>
			internal OpenGlFont Font;
			/// <summary>Whether the message has been announced by the screen reader</summary>
			private bool ScreenReaderAnnounced;

			public override void AddMessage(double currentTime)
			{
				//HACK: No way of changing this at the minute....
				Font = Program.Renderer.Fonts.SmallFont;
				QueueForRemoval = false;
				MessageToDisplay = InternalText;
				ScreenReaderAnnounced = false;
			}

			public override void Update()
			{
				//If our message timeout is greater than or equal to the current time, queue it for removal
				bool remove = Program.CurrentRoute.SecondsSinceMidnight >= Timeout;

				switch (Depencency)
				{
					case MessageDependency.AccessibilityHelper:
					case MessageDependency.RouteLimit:
					{
						double spd = Math.Abs(TrainManager.PlayerTrain.CurrentSpeed);
						double lim = TrainManager.PlayerTrain.CurrentRouteLimit;
						//Get the speed and limit in km/h
						spd = Math.Round(spd * 3.6);
						lim = Math.Round(lim * 3.6);
						remove = spd <= lim;
						string s = InternalText, t;
						if (lim == double.PositiveInfinity)
						{
							s = s.Replace("[limit]", "unlimited");
							s = s.Replace("[unit]", string.Empty);
						}
						else
						{
							if (Interface.CurrentOptions.SpeedConversionFactor != 0.0)
							{
								spd = Math.Round(spd * Interface.CurrentOptions.SpeedConversionFactor);
								lim = Math.Round(lim * Interface.CurrentOptions.SpeedConversionFactor);
							}
							t = spd.ToString(System.Globalization.CultureInfo.InvariantCulture);
							s = s.Replace("[speed]", t);
							t = lim.ToString(System.Globalization.CultureInfo.InvariantCulture);
							s = s.Replace("[limit]", t);
							s = s.Replace("[unit]", Interface.CurrentOptions.UnitOfSpeed);
						}
						MessageToDisplay = s;
					} break;
					case MessageDependency.PassedRedSignal:
					case MessageDependency.SectionLimit:
					{
						double spd = Math.Abs(TrainManager.PlayerTrain.CurrentSpeed);
						double lim = TrainManager.PlayerTrain.CurrentSectionLimit;
						spd = Math.Round(spd * 3.6);
						lim = Math.Round(lim * 3.6);
						remove = spd <= lim;
						string s = InternalText, t;
						if (Interface.CurrentOptions.SpeedConversionFactor != 0.0)
						{
							spd = Math.Round(spd * Interface.CurrentOptions.SpeedConversionFactor);
							lim = Math.Round(lim * Interface.CurrentOptions.SpeedConversionFactor);
						}
						t = spd.ToString(System.Globalization.CultureInfo.InvariantCulture);
						s = s.Replace("[speed]", t);
						t = lim.ToString(System.Globalization.CultureInfo.InvariantCulture);
						s = s.Replace("[limit]", t);
						s = s.Replace("[unit]", Interface.CurrentOptions.UnitOfSpeed);
						MessageToDisplay = s;
					} break;
					case MessageDependency.StationArrival:
					case MessageDependency.StationDeparture:
					{
						int j = TrainManager.PlayerTrain.Station;
						if (j >= 0 & TrainManager.PlayerTrain.StationState != TrainStopState.Completed)
						{
							double d = TrainManager.PlayerTrain.StationDepartureTime - Program.CurrentRoute.SecondsSinceMidnight + 1.0;
							if (d < 0.0) d = 0.0;
							string s = InternalText;
							TimeSpan a = TimeSpan.FromSeconds(d);
							System.Globalization.CultureInfo Culture = System.Globalization.CultureInfo.InvariantCulture;
							string t = a.Hours.ToString("00", Culture) + ":" + a.Minutes.ToString("00", Culture) + ":" + a.Seconds.ToString("00", Culture);
							s = s.Replace("[time]", t);
							s = s.Replace("[name]", Program.CurrentRoute.Stations[j].Name);
							MessageToDisplay = s;
							if (d > 0.0) remove = false;
						}
						else
						{
							//Queue the mesasge for removal if we have completed the station stop for this message
							remove = true;
						}
					} break;
					default:
						MessageToDisplay = InternalText;
						break;
				}

				if (Interface.CurrentOptions.ScreenReaderAvailable && !ScreenReaderAnnounced)
				{
					if (!Tolk.Output((string) MessageToDisplay))
					{
						Interface.CurrentOptions.ScreenReaderAvailable = false;
					}
					ScreenReaderAnnounced = true;
				}
				if (remove)
				{
					if (Timeout == double.PositiveInfinity)
					{
						Timeout = Program.CurrentRoute.SecondsSinceMidnight - 1.0;
					}
					//Remove the message if it has completely faded out
					//NOTE: The fadeout is done in the renderer itself...
					if (Program.CurrentRoute.SecondsSinceMidnight >= Timeout & RendererAlpha == 0.0)
					{
						QueueForRemoval = true;
					}
				}
			}
		}

		



		
	}
}
